# üìò PH·∫¶N 4: C√ÅC C·∫§U TR√öC D·ªÆ LI·ªÜU CHUY√äN BI·ªÜT

- [üìò PH·∫¶N 4: C√ÅC C·∫§U TR√öC D·ªÆ LI·ªÜU CHUY√äN BI·ªÜT](#-ph·∫ßn-4-c√°c-c·∫•u-tr√∫c-d·ªØ-li·ªáu-chuy√™n-bi·ªát)
  - [üéØ M·ª•c ti√™u t·ªïng qu√°t](#-m·ª•c-ti√™u-t·ªïng-qu√°t)
  - [üßë‚Äçüè´ B√†i 1: C√¢y c√¢n b·∫±ng (AVL, Red-Black Trees)](#-b√†i-1-c√¢y-c√¢n-b·∫±ng-avl-red-black-trees)
    - [C√¢y AVL](#c√¢y-avl)
      - [C√°c t√≠nh ch·∫•t c·ªßa c√¢y AVL](#c√°c-t√≠nh-ch·∫•t-c·ªßa-c√¢y-avl)
      - [C√°c thao t√°c t√°i c√¢n b·∫±ng](#c√°c-thao-t√°c-t√°i-c√¢n-b·∫±ng)
      - [C√†i ƒë·∫∑t c√¢y AVL ƒë·∫ßy ƒë·ªß](#c√†i-ƒë·∫∑t-c√¢y-avl-ƒë·∫ßy-ƒë·ªß)
    - [C√¢y Red-Black](#c√¢y-red-black)
      - [T√≠nh ch·∫•t c·ªßa c√¢y Red-Black](#t√≠nh-ch·∫•t-c·ªßa-c√¢y-red-black)
      - [C√†i ƒë·∫∑t c√¢y Red-Black](#c√†i-ƒë·∫∑t-c√¢y-red-black)
    - [So s√°nh c√¢y AVL v√† c√¢y Red-Black](#so-s√°nh-c√¢y-avl-v√†-c√¢y-red-black)
  - [üßë‚Äçüè´ B√†i 2: C√¢y B v√† B+](#-b√†i-2-c√¢y-b-v√†-b)
    - [C√¢y B](#c√¢y-b)
      - [T√≠nh ch·∫•t c·ªßa c√¢y B b·∫≠c M](#t√≠nh-ch·∫•t-c·ªßa-c√¢y-b-b·∫≠c-m)
      - [C·∫•u tr√∫c n√∫t trong c√¢y B](#c·∫•u-tr√∫c-n√∫t-trong-c√¢y-b)
      - [C√†i ƒë·∫∑t c√¢y B](#c√†i-ƒë·∫∑t-c√¢y-b)
    - [C√¢y B+](#c√¢y-b-1)
      - [C·∫•u tr√∫c n√∫t trong c√¢y B+](#c·∫•u-tr√∫c-n√∫t-trong-c√¢y-b-1)
      - [C√†i ƒë·∫∑t c√¢y B+ (phi√™n b·∫£n ƒë∆°n gi·∫£n)](#c√†i-ƒë·∫∑t-c√¢y-b-phi√™n-b·∫£n-ƒë∆°n-gi·∫£n)
  - [üßë‚Äçüè´ B√†i 3: Heap v√† Priority Queue](#-b√†i-3-heap-v√†-priority-queue)
    - [C·∫•u tr√∫c Heap](#c·∫•u-tr√∫c-heap)
    - [C√†i ƒë·∫∑t Heap](#c√†i-ƒë·∫∑t-heap)
      - [Max Heap](#max-heap)
      - [Min Heap](#min-heap)
    - [Priority Queue](#priority-queue)
      - [C√†i ƒë·∫∑t Priority Queue s·ª≠ d·ª•ng Heap](#c√†i-ƒë·∫∑t-priority-queue-s·ª≠-d·ª•ng-heap)
    - [Heap Sort](#heap-sort)
    - [5. ·ª®ng d·ª•ng c·ªßa Heap v√† Priority Queue](#5-·ª©ng-d·ª•ng-c·ªßa-heap-v√†-priority-queue)
    - [6. B√†i t·∫≠p](#6-b√†i-t·∫≠p)
      - [B√†i t·∫≠p 1: C√†i ƒë·∫∑t thu·∫≠t to√°n t√¨m k ph·∫ßn t·ª≠ l·ªõn nh·∫•t trong m·ªôt m·∫£ng s·ª≠ d·ª•ng min-heap](#b√†i-t·∫≠p-1-c√†i-ƒë·∫∑t-thu·∫≠t-to√°n-t√¨m-k-ph·∫ßn-t·ª≠-l·ªõn-nh·∫•t-trong-m·ªôt-m·∫£ng-s·ª≠-d·ª•ng-min-heap)
      - [B√†i t·∫≠p 2: S·ª≠ d·ª•ng priority queue ƒë·ªÉ l·∫≠p l·ªãch CPU (x·ª≠ l√Ω c√°c ti·∫øn tr√¨nh theo ƒë·ªô ∆∞u ti√™n)](#b√†i-t·∫≠p-2-s·ª≠-d·ª•ng-priority-queue-ƒë·ªÉ-l·∫≠p-l·ªãch-cpu-x·ª≠-l√Ω-c√°c-ti·∫øn-tr√¨nh-theo-ƒë·ªô-∆∞u-ti√™n)
    - [7. Ph√¢n t√≠ch hi·ªáu nƒÉng](#7-ph√¢n-t√≠ch-hi·ªáu-nƒÉng)
  - [üßë‚Äçüè´ B√†i 4: Trie v√† ·ª©ng d·ª•ng](#-b√†i-4-trie-v√†-·ª©ng-d·ª•ng)
    - [C·∫•u tr√∫c d·ªØ li·ªáu Trie](#c·∫•u-tr√∫c-d·ªØ-li·ªáu-trie)
      - [ƒê·∫∑c ƒëi·ªÉm c·ªßa Trie](#ƒë·∫∑c-ƒëi·ªÉm-c·ªßa-trie)
      - [C·∫•u tr√∫c n√∫t c·ªßa Trie](#c·∫•u-tr√∫c-n√∫t-c·ªßa-trie)
    - [C√†i ƒë·∫∑t c∆° b·∫£n c·ªßa Trie](#c√†i-ƒë·∫∑t-c∆°-b·∫£n-c·ªßa-trie)
    - [·ª®ng d·ª•ng c·ªßa Trie](#·ª©ng-d·ª•ng-c·ªßa-trie)
      - [T·ª± ƒë·ªông ho√†n th√†nh (Autocomplete)](#t·ª±-ƒë·ªông-ho√†n-th√†nh-autocomplete)
      - [Ki·ªÉm tra ti·ªÅn t·ªë (Prefix checking)](#ki·ªÉm-tra-ti·ªÅn-t·ªë-prefix-checking)
      - [T√¨m ki·∫øm t·ª´ trong ma tr·∫≠n (Word Search)](#t√¨m-ki·∫øm-t·ª´-trong-ma-tr·∫≠n-word-search)
      - [T·ª´ ƒëi·ªÉn (Dictionary)](#t·ª´-ƒëi·ªÉn-dictionary)
    - [Trie v·ªõi b·∫£ng bƒÉm (Hash Trie)](#trie-v·ªõi-b·∫£ng-bƒÉm-hash-trie)
    - [Trie n√©n (Compressed Trie)](#trie-n√©n-compressed-trie)
    - [Ph√¢n t√≠ch hi·ªáu nƒÉng c·ªßa Trie](#ph√¢n-t√≠ch-hi·ªáu-nƒÉng-c·ªßa-trie)
    - [So s√°nh v·ªõi c√°c c·∫•u tr√∫c d·ªØ li·ªáu kh√°c](#so-s√°nh-v·ªõi-c√°c-c·∫•u-tr√∫c-d·ªØ-li·ªáu-kh√°c)
    - [B√†i t·∫≠p](#b√†i-t·∫≠p)
      - [B√†i t·∫≠p 1: ƒê·∫øm s·ªë t·ª´ c√≥ ti·ªÅn t·ªë chung](#b√†i-t·∫≠p-1-ƒë·∫øm-s·ªë-t·ª´-c√≥-ti·ªÅn-t·ªë-chung)
      - [B√†i t·∫≠p 2: T√¨m t·ª´ d√†i nh·∫•t c√≥ t·∫•t c·∫£ ti·ªÅn t·ªë trong t·ª´ ƒëi·ªÉn](#b√†i-t·∫≠p-2-t√¨m-t·ª´-d√†i-nh·∫•t-c√≥-t·∫•t-c·∫£-ti·ªÅn-t·ªë-trong-t·ª´-ƒëi·ªÉn)
      - [B√†i t·∫≠p 3: X√¢y d·ª±ng tr√≤ ch∆°i t√¨m t·ª´ (Word Boggle)](#b√†i-t·∫≠p-3-x√¢y-d·ª±ng-tr√≤-ch∆°i-t√¨m-t·ª´-word-boggle)
  - [üßë‚Äçüè´ B√†i 5: Segment Tree v√† Fenwick Tree](#-b√†i-5-segment-tree-v√†-fenwick-tree)
    - [Segment Tree](#segment-tree)
      - [T√≠nh ch·∫•t c·ªßa Segment Tree](#t√≠nh-ch·∫•t-c·ªßa-segment-tree)
      - [C√†i ƒë·∫∑t Segment Tree](#c√†i-ƒë·∫∑t-segment-tree)
    - [Lazy Propagation trong Segment Tree](#lazy-propagation-trong-segment-tree)
    - [Fenwick Tree (Binary Indexed Tree)](#fenwick-tree-binary-indexed-tree)
      - [T√≠nh ch·∫•t c·ªßa Fenwick Tree](#t√≠nh-ch·∫•t-c·ªßa-fenwick-tree)
      - [C√†i ƒë·∫∑t Fenwick Tree](#c√†i-ƒë·∫∑t-fenwick-tree)
    - [Fenwick Tree 2D](#fenwick-tree-2d)
    - [So s√°nh Segment Tree v√† Fenwick Tree](#so-s√°nh-segment-tree-v√†-fenwick-tree)
    - [·ª®ng d·ª•ng c·ªßa Segment Tree v√† Fenwick Tree](#·ª©ng-d·ª•ng-c·ªßa-segment-tree-v√†-fenwick-tree)
    - [B√†i luy·ªán t·∫≠p](#b√†i-luy·ªán-t·∫≠p)
      - [B√†i t·∫≠p 1: Truy v·∫•n t·ªïng ƒëo·∫°n v√† c·∫≠p nh·∫≠t ph·∫ßn t·ª≠](#b√†i-t·∫≠p-1-truy-v·∫•n-t·ªïng-ƒëo·∫°n-v√†-c·∫≠p-nh·∫≠t-ph·∫ßn-t·ª≠)
      - [B√†i t·∫≠p 2: Truy v·∫•n gi√° tr·ªã nh·ªè nh·∫•t ƒëo·∫°n](#b√†i-t·∫≠p-2-truy-v·∫•n-gi√°-tr·ªã-nh·ªè-nh·∫•t-ƒëo·∫°n)
      - [B√†i t·∫≠p 3: ƒê·∫øm s·ªë ph·∫ßn t·ª≠ l·ªõn h∆°n ho·∫∑c b·∫±ng k trong ƒëo·∫°n \[l, r\]](#b√†i-t·∫≠p-3-ƒë·∫øm-s·ªë-ph·∫ßn-t·ª≠-l·ªõn-h∆°n-ho·∫∑c-b·∫±ng-k-trong-ƒëo·∫°n-l-r)
  - [üßë‚Äçüíª B√†i t·∫≠p l·ªõn: X√¢y d·ª±ng h·ªá th·ªëng t√¨m ki·∫øm vƒÉn b·∫£n ƒë∆°n gi·∫£n](#-b√†i-t·∫≠p-l·ªõn-x√¢y-d·ª±ng-h·ªá-th·ªëng-t√¨m-ki·∫øm-vƒÉn-b·∫£n-ƒë∆°n-gi·∫£n)
    - [M√¥ t·∫£ b√†i to√°n](#m√¥-t·∫£-b√†i-to√°n)
    - [C√°c th√†nh ph·∫ßn c·∫ßn tri·ªÉn khai](#c√°c-th√†nh-ph·∫ßn-c·∫ßn-tri·ªÉn-khai)
    - [C√°c t√≠nh nƒÉng m·ªü r·ªông c√≥ th·ªÉ th√™m v√†o](#c√°c-t√≠nh-nƒÉng-m·ªü-r·ªông-c√≥-th·ªÉ-th√™m-v√†o)

## üéØ M·ª•c ti√™u t·ªïng qu√°t

- Hi·ªÉu v√† c√†i ƒë·∫∑t ƒë∆∞·ª£c c√°c c·∫•u tr√∫c d·ªØ li·ªáu n√¢ng cao nh∆∞ c√¢y c√¢n b·∫±ng, c√¢y B/B+, Heap, Trie, Segment Tree.
- Ph√¢n t√≠ch ƒë∆∞·ª£c ∆∞u nh∆∞·ª£c ƒëi·ªÉm c·ªßa t·ª´ng c·∫•u tr√∫c v√† bi·∫øt l·ª±a ch·ªçn c·∫•u tr√∫c ph√π h·ª£p v·ªõi b√†i to√°n.
- √Åp d·ª•ng c√°c c·∫•u tr√∫c d·ªØ li·ªáu chuy√™n bi·ªát v√†o c√°c b√†i to√°n th·ª±c t·∫ø.
- T·ªëi ∆∞u h√≥a gi·∫£i ph√°p s·ª≠ d·ª•ng c√°c c·∫•u tr√∫c d·ªØ li·ªáu ƒë·∫∑c th√π.

---

## üßë‚Äçüè´ B√†i 1: C√¢y c√¢n b·∫±ng (AVL, Red-Black Trees)

### C√¢y AVL

C√¢y AVL l√† c√¢y nh·ªã ph√¢n t√¨m ki·∫øm t·ª± c√¢n b·∫±ng, ƒë·∫£m b·∫£o chi·ªÅu cao c·ªßa hai c√¢y con l·ªách nhau kh√¥ng qu√° 1 ƒë∆°n v·ªã.

#### C√°c t√≠nh ch·∫•t c·ªßa c√¢y AVL

- M·ªói n√∫t c√≥ h·ªá s·ªë c√¢n b·∫±ng (balance factor) = chi·ªÅu cao c√¢y con tr√°i - chi·ªÅu cao c√¢y con ph·∫£i
- H·ªá s·ªë c√¢n b·∫±ng c·ªßa m·ªói n√∫t ph·∫£i l√† -1, 0, ho·∫∑c +1
- C√°c thao t√°c t√¨m ki·∫øm, ch√®n, x√≥a ƒë·ªÅu c√≥ ƒë·ªô ph·ª©c t·∫°p O(log n)

#### C√°c thao t√°c t√°i c√¢n b·∫±ng

1. Xoay ph·∫£i (Right rotation):

   ```java
   private Node rightRotate(Node y) {
       Node x = y.left;
       Node T2 = x.right;

       // Th·ª±c hi·ªán xoay
       x.right = y;
       y.left = T2;

       // C·∫≠p nh·∫≠t chi·ªÅu cao
       y.height = Math.max(height(y.left), height(y.right)) + 1;
       x.height = Math.max(height(x.left), height(x.right)) + 1;

       return x;
   }
   ```

2. **Xoay tr√°i (Left rotation):**

   ```java
   private Node leftRotate(Node x) {
       Node y = x.right;
       Node T2 = y.left;

       // Th·ª±c hi·ªán xoay
       y.left = x;
       x.right = T2;

       // C·∫≠p nh·∫≠t chi·ªÅu cao
       x.height = Math.max(height(x.left), height(x.right)) + 1;
       y.height = Math.max(height(y.left), height(y.right)) + 1;

       return y;
   }
   ```

#### C√†i ƒë·∫∑t c√¢y AVL ƒë·∫ßy ƒë·ªß

```java
public class AVLTree {
    private class Node {
        int key, height;
        Node left, right;

        Node(int key) {
            this.key = key;
            this.height = 1; // N√∫t l√° m·ªõi c√≥ chi·ªÅu cao l√† 1
        }
    }

    private Node root;

    // L·∫•y chi·ªÅu cao c·ªßa n√∫t
    private int height(Node node) {
        if (node == null)
            return 0;
        return node.height;
    }

    // L·∫•y h·ªá s·ªë c√¢n b·∫±ng c·ªßa n√∫t
    private int getBalance(Node node) {
        if (node == null)
            return 0;
        return height(node.left) - height(node.right);
    }

    // Ch√®n m·ªôt kh√≥a m·ªõi v√†o c√¢y
    public void insert(int key) {
        root = insert(root, key);
    }

    private Node insert(Node node, int key) {
        // 1. Th·ª±c hi·ªán ch√®n BST th√¥ng th∆∞·ªùng
        if (node == null)
            return new Node(key);

        if (key < node.key)
            node.left = insert(node.left, key);
        else if (key > node.key)
            node.right = insert(node.right, key);
        else // Kh√¥ng cho ph√©p tr√πng kh√≥a
            return node;

        // 2. C·∫≠p nh·∫≠t chi·ªÅu cao c·ªßa n√∫t hi·ªán t·∫°i
        node.height = 1 + Math.max(height(node.left), height(node.right));

        // 3. L·∫•y h·ªá s·ªë c√¢n b·∫±ng ƒë·ªÉ ki·ªÉm tra xem n√∫t n√†y c√≥ m·∫•t c√¢n b·∫±ng kh√¥ng
        int balance = getBalance(node);

        // 4. N·∫øu m·∫•t c√¢n b·∫±ng, c√≥ 4 tr∆∞·ªùng h·ª£p

        // Left Left Case
        if (balance > 1 && key < node.left.key)
            return rightRotate(node);

        // Right Right Case
        if (balance < -1 && key > node.right.key)
            return leftRotate(node);

        // Left Right Case
        if (balance > 1 && key > node.left.key) {
            node.left = leftRotate(node.left);
            return rightRotate(node);
        }

        // Right Left Case
        if (balance < -1 && key < node.right.key) {
            node.right = rightRotate(node.right);
            return leftRotate(node);
        }

        return node;
    }

    // X√≥a m·ªôt kh√≥a kh·ªèi c√¢y
    public void delete(int key) {
        root = delete(root, key);
    }

    private Node delete(Node root, int key) {
        // 1. Th·ª±c hi·ªán x√≥a BST th√¥ng th∆∞·ªùng
        if (root == null)
            return root;

        if (key < root.key)
            root.left = delete(root.left, key);
        else if (key > root.key)
            root.right = delete(root.right, key);
        else {
            // N√∫t c√≥ 0 ho·∫∑c 1 con
            if (root.left == null || root.right == null) {
                Node temp = (root.left != null) ? root.left : root.right;

                // Kh√¥ng c√≥ con
                if (temp == null) {
                    temp = root;
                    root = null;
                }
                // M·ªôt con
                else {
                    root = temp;
                }
            }
            // N√∫t c√≥ 2 con
            else {
                // T√¨m n√∫t k·∫ø ti·∫øp theo th·ª© t·ª± (nh·ªè nh·∫•t trong c√¢y con ph·∫£i)
                Node temp = minValueNode(root.right);

                // Sao ch√©p gi√° tr·ªã k·∫ø ti·∫øp v√†o n√∫t hi·ªán t·∫°i
                root.key = temp.key;

                // X√≥a n√∫t k·∫ø ti·∫øp
                root.right = delete(root.right, temp.key);
            }
        }

        // N·∫øu c√¢y ch·ªâ c√≥ m·ªôt n√∫t th√¨ return
        if (root == null)
            return root;

        // 2. C·∫≠p nh·∫≠t chi·ªÅu cao
        root.height = 1 + Math.max(height(root.left), height(root.right));

        // 3. Ki·ªÉm tra h·ªá s·ªë c√¢n b·∫±ng
        int balance = getBalance(root);

        // 4. N·∫øu m·∫•t c√¢n b·∫±ng, t√°i c√¢n b·∫±ng

        // Left Left Case
        if (balance > 1 && getBalance(root.left) >= 0)
            return rightRotate(root);

        // Left Right Case
        if (balance > 1 && getBalance(root.left) < 0) {
            root.left = leftRotate(root.left);
            return rightRotate(root);
        }

        // Right Right Case
        if (balance < -1 && getBalance(root.right) <= 0)
            return leftRotate(root);

        // Right Left Case
        if (balance < -1 && getBalance(root.right) > 0) {
            root.right = rightRotate(root.right);
            return leftRotate(root);
        }

        return root;
    }

    private Node minValueNode(Node node) {
        Node current = node;

        // T√¨m n√∫t tr√°i nh·∫•t (nh·ªè nh·∫•t)
        while (current.left != null)
            current = current.left;

        return current;
    }

    // Duy·ªát c√¢y theo th·ª© t·ª±
    public void inorder() {
        inorder(root);
        System.out.println();
    }

    private void inorder(Node node) {
        if (node != null) {
            inorder(node.left);
            System.out.print(node.key + " ");
            inorder(node.right);
        }
    }
}
```

### C√¢y Red-Black

C√¢y Red-Black l√† m·ªôt lo·∫°i c√¢y nh·ªã ph√¢n t√¨m ki·∫øm t·ª± c√¢n b·∫±ng v·ªõi c√°c t√≠nh ch·∫•t ƒë·∫∑c bi·ªát ƒë·ªÉ ƒë·∫£m b·∫£o c√¢n b·∫±ng.

#### T√≠nh ch·∫•t c·ªßa c√¢y Red-Black

1. M·ªói n√∫t c√≥ m√†u ƒë·ªè ho·∫∑c ƒëen
2. N√∫t g·ªëc lu√¥n c√≥ m√†u ƒëen
3. C√°c n√∫t l√° NULL ƒë·ªÅu c√≥ m√†u ƒëen
4. N√∫t ƒë·ªè kh√¥ng th·ªÉ c√≥ con ƒë·ªè (kh√¥ng c√≥ 2 n√∫t ƒë·ªè li√™n ti·∫øp)
5. M·ªçi ƒë∆∞·ªùng ƒëi t·ª´ n√∫t b·∫•t k·ª≥ ƒë·∫øn c√°c n√∫t l√° ƒë·ªÅu c√≥ c√πng s·ªë l∆∞·ª£ng n√∫t ƒëen

#### C√†i ƒë·∫∑t c√¢y Red-Black

```java
public class RedBlackTree {
    private static final boolean RED = true;
    private static final boolean BLACK = false;

    private class Node {
        int key;
        Node left, right;
        boolean color; // true l√† RED, false l√† BLACK

        Node(int key) {
            this.key = key;
            this.color = RED; // N√∫t m·ªõi lu√¥n l√† RED
        }
    }

    private Node root;

    // Ki·ªÉm tra m√†u c·ªßa n√∫t
    private boolean isRed(Node node) {
        if (node == null)
            return false; // NULL nodes are BLACK
        return node.color == RED;
    }

    // Xoay tr√°i
    private Node rotateLeft(Node h) {
        Node x = h.right;
        h.right = x.left;
        x.left = h;
        x.color = h.color;
        h.color = RED;
        return x;
    }

    // Xoay ph·∫£i
    private Node rotateRight(Node h) {
        Node x = h.left;
        h.left = x.right;
        x.right = h;
        x.color = h.color;
        h.color = RED;
        return x;
    }

    // ƒê·∫£o m√†u c·ªßa n√∫t v√† hai con
    private void flipColors(Node h) {
        h.color = !h.color;
        h.left.color = !h.left.color;
        h.right.color = !h.right.color;
    }

    // Ch√®n m·ªôt kh√≥a v√†o c√¢y
    public void insert(int key) {
        root = insert(root, key);
        root.color = BLACK; // ƒê·∫£m b·∫£o g·ªëc lu√¥n ƒëen
    }

    private Node insert(Node h, int key) {
        if (h == null)
            return new Node(key);

        if (key < h.key)
            h.left = insert(h.left, key);
        else if (key > h.key)
            h.right = insert(h.right, key);
        else
            h.key = key; // C·∫≠p nh·∫≠t n·∫øu tr√πng kh√≥a

        // C√¢n b·∫±ng c√¢y

        // N·∫øu n√∫t ph·∫£i ƒë·ªè v√† n√∫t tr√°i ƒëen: xoay tr√°i
        if (isRed(h.right) && !isRed(h.left))
            h = rotateLeft(h);

        // N·∫øu n√∫t tr√°i ƒë·ªè v√† con tr√°i c·ªßa n√≥ c≈©ng ƒë·ªè: xoay ph·∫£i
        if (isRed(h.left) && isRed(h.left.left))
            h = rotateRight(h);

        // N·∫øu c·∫£ n√∫t tr√°i v√† n√∫t ph·∫£i ƒë·ªÅu ƒë·ªè: ƒë·∫£o m√†u
        if (isRed(h.left) && isRed(h.right))
            flipColors(h);

        return h;
    }

    // Duy·ªát c√¢y theo th·ª© t·ª±
    public void inorder() {
        inorder(root);
        System.out.println();
    }

    private void inorder(Node node) {
        if (node != null) {
            inorder(node.left);
            System.out.print(node.key + "(" + (node.color ? "R" : "B") + ") ");
            inorder(node.right);
        }
    }
}
```

### So s√°nh c√¢y AVL v√† c√¢y Red-Black

| Ti√™u ch√≠      | C√¢y AVL                                | C√¢y Red-Black         |
| ------------- | -------------------------------------- | --------------------- |
| C√¢n b·∫±ng      | Nghi√™m ng·∫∑t (h·ªá s·ªë c√¢n b·∫±ng <= 1)      | √çt nghi√™m ng·∫∑t h∆°n    |
| Chi·ªÅu cao     | ~ 1.44 log(n)                          | ~ 2 log(n)            |
| Thao t√°c ch√®n | T·ªëi ƒëa 2 xoay                          | T·ªëi ƒëa 2 xoay         |
| Thao t√°c x√≥a  | T·ªëi ƒëa log(n) xoay                     | T·ªëi ƒëa 3 xoay         |
| B·ªô nh·ªõ        | 1 bit h·ªá s·ªë c√¢n b·∫±ng/chi·ªÅu cao m·ªói n√∫t | 1 bit m√†u m·ªói n√∫t     |
| T√¨m ki·∫øm      | Nhanh h∆°n do c√¢n b·∫±ng t·ªët              | Ch·∫≠m h∆°n m·ªôt ch√∫t     |
| ·ª®ng d·ª•ng      | Tra c·ª©u th∆∞·ªùng xuy√™n                   | Ch√®n/x√≥a th∆∞·ªùng xuy√™n |

---

## üßë‚Äçüè´ B√†i 2: C√¢y B v√† B+

### C√¢y B

C√¢y B l√† m·ªôt c·∫•u tr√∫c c√¢y t·ª± c√¢n b·∫±ng, m·ªói n√∫t c√≥ th·ªÉ ch·ª©a nhi·ªÅu kh√≥a v√† c√≥ nhi·ªÅu con. C√¢y B th∆∞·ªùng ƒë∆∞·ª£c s·ª≠ d·ª•ng trong c√°c h·ªá th·ªëng t·∫≠p tin v√† c∆° s·ªü d·ªØ li·ªáu.

#### T√≠nh ch·∫•t c·ªßa c√¢y B b·∫≠c M

1. M·ªçi n√∫t tr·ª´ n√∫t g·ªëc ƒë·ªÅu ch·ª©a t·ª´ ‚åàM/2‚åâ-1 ƒë·∫øn M-1 kh√≥a
2. N√∫t g·ªëc ch·ª©a t·ª´ 1 ƒë·∫øn M-1 kh√≥a
3. N√∫t c√≥ k kh√≥a s·∫Ω c√≥ k+1 con
4. T·∫•t c·∫£ c√°c n√∫t l√° ƒë·ªÅu n·∫±m ·ªü c√πng m·ªôt m·ª©c

#### C·∫•u tr√∫c n√∫t trong c√¢y B

```java
class BTreeNode {
    int[] keys;        // M·∫£ng c√°c kh√≥a
    int t;             // B·∫≠c t·ªëi thi·ªÉu (s·ªë kh√≥a t·ªëi thi·ªÉu l√† t-1)
    BTreeNode[] children; // M·∫£ng c√°c con
    int n;             // S·ªë kh√≥a hi·ªán t·∫°i
    boolean leaf;      // true n·∫øu l√† n√∫t l√°

    public BTreeNode(int t, boolean leaf) {
        this.t = t;
        this.leaf = leaf;
        this.keys = new int[2*t - 1]; // M·ªói n√∫t c√≥ th·ªÉ ch·ª©a t·ªëi ƒëa 2t-1 kh√≥a
        this.children = new BTreeNode[2*t]; // M·ªói n√∫t c√≥ t·ªëi ƒëa 2t con
        this.n = 0; // Kh·ªüi t·∫°o v·ªõi 0 kh√≥a
    }
}
```

#### C√†i ƒë·∫∑t c√¢y B

```java
public class BTree {
    private BTreeNode root;
    private int t; // B·∫≠c t·ªëi thi·ªÉu

    public BTree(int t) {
        this.root = null;
        this.t = t;
    }

    // T√¨m ki·∫øm m·ªôt kh√≥a trong c√¢y
    public BTreeNode search(int key) {
        if (root == null)
            return null;
        return search(root, key);
    }

    private BTreeNode search(BTreeNode node, int key) {
        // T√¨m v·ªã tr√≠ c·ªßa kh√≥a trong n√∫t hi·ªán t·∫°i
        int i = 0;
        while (i < node.n && key > node.keys[i])
            i++;

        // N·∫øu t√¨m th·∫•y kh√≥a
        if (i < node.n && key == node.keys[i])
            return node;

        // N·∫øu l√† n√∫t l√° v√† kh√¥ng t√¨m th·∫•y
        if (node.leaf)
            return null;

        // Ti·∫øp t·ª•c t√¨m ki·∫øm ·ªü n√∫t con
        return search(node.children[i], key);
    }

    // Ch√®n m·ªôt kh√≥a v√†o c√¢y
    public void insert(int key) {
        // N·∫øu c√¢y r·ªóng
        if (root == null) {
            root = new BTreeNode(t, true);
            root.keys[0] = key;
            root.n = 1;
        } else {
            // N·∫øu g·ªëc ƒë·∫ßy, c√¢y s·∫Ω tƒÉng chi·ªÅu cao
            if (root.n == 2*t - 1) {
                BTreeNode s = new BTreeNode(t, false);
                s.children[0] = root;
                // T√°ch g·ªëc c≈© v√† di chuy·ªÉn m·ªôt kh√≥a l√™n
                splitChild(s, 0);
                // G·ªëc m·ªõi c√≥ 2 con, quy·∫øt ƒë·ªãnh con n√†o s·∫Ω ch·ª©a kh√≥a m·ªõi
                int i = 0;
                if (s.keys[0] < key)
                    i++;
                insertNonFull(s.children[i], key);

                // ƒê·ªïi g·ªëc
                root = s;
            } else {
                insertNonFull(root, key);
            }
        }
    }

    // Ch√®n kh√≥a v√†o n√∫t ch∆∞a ƒë·∫ßy
    private void insertNonFull(BTreeNode node, int key) {
        // Kh·ªüi t·∫°o v·ªã tr√≠ c·ªßa kh√≥a cu·ªëi c√πng
        int i = node.n - 1;

        // N·∫øu l√† n√∫t l√°
        if (node.leaf) {
            // T√¨m v·ªã tr√≠ c·ªßa kh√≥a m·ªõi v√† d·ªãch chuy·ªÉn c√°c kh√≥a l·ªõn h∆°n
            while (i >= 0 && key < node.keys[i]) {
                node.keys[i+1] = node.keys[i];
                i--;
            }

            // Ch√®n kh√≥a m·ªõi
            node.keys[i+1] = key;
            node.n++;
        } else { // N·∫øu kh√¥ng ph·∫£i n√∫t l√°
            // T√¨m n√∫t con s·∫Ω ch·ª©a kh√≥a m·ªõi
            while (i >= 0 && key < node.keys[i])
                i--;

            i++;
            // N·∫øu n√∫t con ƒë·∫ßy, t√°ch n√≥
            if (node.children[i].n == 2*t - 1) {
                splitChild(node, i);

                // Sau khi t√°ch, kh√≥a gi·ªØa ƒë∆∞·ª£c ƒë·∫©y l√™n v√† n√∫t con ƒë∆∞·ª£c chia ƒë√¥i
                if (key > node.keys[i])
                    i++;
            }
            insertNonFull(node.children[i], key);
        }
    }

    // T√°ch n√∫t con th·ª© i c·ªßa node
    private void splitChild(BTreeNode node, int i) {
        BTreeNode y = node.children[i]; // N√∫t con c·∫ßn t√°ch
        BTreeNode z = new BTreeNode(t, y.leaf); // N√∫t m·ªõi

        z.n = t - 1;

        // Sao ch√©p n·ª≠a sau c·ªßa y v√†o z
        for (int j = 0; j < t-1; j++)
            z.keys[j] = y.keys[j+t];

        // Sao ch√©p c√°c con t∆∞∆°ng ·ª©ng n·∫øu kh√¥ng ph·∫£i n√∫t l√°
        if (!y.leaf) {
            for (int j = 0; j < t; j++)
                z.children[j] = y.children[j+t];
        }

        // Gi·∫£m s·ªë kh√≥a trong y
        y.n = t - 1;

        // D·ªãch chuy·ªÉn c√°c con c·ªßa node ƒë·ªÉ ch·ª©a z
        for (int j = node.n; j > i; j--)
            node.children[j+1] = node.children[j];

        // Li√™n k·∫øt n√∫t con m·ªõi
        node.children[i+1] = z;

        // D·ªãch chuy·ªÉn c√°c kh√≥a c·ªßa node ƒë·ªÉ ch√®n kh√≥a t·ª´ y
        for (int j = node.n-1; j >= i; j--)
            node.keys[j+1] = node.keys[j];

        // Sao ch√©p kh√≥a gi·ªØa t·ª´ y v√†o node
        node.keys[i] = y.keys[t-1];

        // TƒÉng s·ªë kh√≥a trong node
        node.n++;
    }

    // In c√¢y
    public void traverse() {
        if (root != null)
            traverse(root);
        System.out.println();
    }

    private void traverse(BTreeNode node) {
        int i;
        for (i = 0; i < node.n; i++) {
            // In c√¢y con tr∆∞·ªõc kh√≥a th·ª© i
            if (!node.leaf)
                traverse(node.children[i]);
            System.out.print(node.keys[i] + " ");
        }

        // In c√¢y con cu·ªëi c√πng
        if (!node.leaf)
            traverse(node.children[i]);
    }
}
```

### C√¢y B+

C√¢y B+ l√† m·ªôt bi·∫øn th·ªÉ c·ªßa c√¢y B, nh∆∞ng c√≥ m·ªôt s·ªë kh√°c bi·ªát quan tr·ªçng:

1. T·∫•t c·∫£ kh√≥a ƒë·ªÅu ƒë∆∞·ª£c l∆∞u tr·ªØ ·ªü c√°c n√∫t l√°, ƒë∆∞·ª£c li√™n k·∫øt t·∫°o th√†nh m·ªôt danh s√°ch li√™n k·∫øt
2. C√°c kh√≥a trong n√∫t n·ªôi b·ªô ch·ªâ l√† b·∫£n sao c·ªßa kh√≥a ·ªü n√∫t l√°
3. N√∫t l√° ch·ª©a t·∫•t c·∫£ c√°c kh√≥a v√† con tr·ªè ƒë·∫øn d·ªØ li·ªáu th·ª±c

#### C·∫•u tr√∫c n√∫t trong c√¢y B+

```java
class BPlusTreeNode {
    boolean isLeaf; // true n·∫øu l√† n√∫t l√°
    int[] keys; // M·∫£ng c√°c kh√≥a
    int t; // B·∫≠c t·ªëi thi·ªÉu
    BPlusTreeNode[] children; // M·∫£ng c√°c con (n√∫t n·ªôi)
    BPlusTreeNode next; // Con tr·ªè t·ªõi n√∫t l√° k·∫ø ti·∫øp (ch·ªâ cho n√∫t l√°)
    int n; // S·ªë kh√≥a hi·ªán t·∫°i

    public BPlusTreeNode(int t, boolean isLeaf) {
        this.t = t;
        this.isLeaf = isLeaf;
        this.keys = new int[2*t - 1];
        this.children = new BPlusTreeNode[2*t];
        this.next = null;
        this.n = 0;
    }
}
```

#### C√†i ƒë·∫∑t c√¢y B+ (phi√™n b·∫£n ƒë∆°n gi·∫£n)

```java
public class BPlusTree {
    private BPlusTreeNode root;
    private int t; // B·∫≠c t·ªëi thi·ªÉu
    private static final int DEFAULT_T = 3; // B·∫≠c m·∫∑c ƒë·ªãnh

    public BPlusTree() {
        this(DEFAULT_T);
    }

    public BPlusTree(int t) {
        this.t = t;
        root = new BPlusTreeNode(t, true);
    }

    // T√¨m ki·∫øm m·ªôt kh√≥a trong c√¢y
    public boolean search(int key) {
        if (root == null)
            return false;

        BPlusTreeNode node = findLeafNode(root, key);

        // T√¨m kh√≥a trong n√∫t l√°
        for (int i = 0; i < node.n; i++) {
            if (node.keys[i] == key)
                return true;
        }

        return false;
    }

    // T√¨m n√∫t l√° c√≥ th·ªÉ ch·ª©a kh√≥a
    private BPlusTreeNode findLeafNode(BPlusTreeNode node, int key) {
        if (node.isLeaf)
            return node;

        int i = 0;
        while (i < node.n && key >= node.keys[i])
            i++;

        return findLeafNode(node.children[i], key);
    }

    // Ch√®n m·ªôt kh√≥a v√†o c√¢y
    public void insert(int key) {
        // N·∫øu g·ªëc ƒë·∫ßy, c·∫ßn t√°ch g·ªëc
        if (root.n == 2 * t - 1) {
            BPlusTreeNode newRoot = new BPlusTreeNode(t, false);
            newRoot.children[0] = root;

            // T√°ch g·ªëc c≈©
            splitChild(newRoot, 0);

            // C·∫≠p nh·∫≠t g·ªëc m·ªõi
            root = newRoot;
        }

        insertNonFull(root, key);
    }

    // Ch√®n kh√≥a v√†o n√∫t kh√¥ng ƒë·∫ßy
    private void insertNonFull(BPlusTreeNode node, int key) {
        int i = node.n - 1;

        // N·∫øu l√† n√∫t l√°
        if (node.isLeaf) {
            // T√¨m v·ªã tr√≠ ƒë·ªÉ ch√®n v√† d·ªãch c√°c kh√≥a l·ªõn h∆°n
            while (i >= 0 && key < node.keys[i]) {
                node.keys[i + 1] = node.keys[i];
                i--;
            }


            // Ch√®n kh√≥a m·ªõi
            node.keys[i + 1] = key;
            node.n++;
        } else {
            // N·∫øu kh√¥ng ph·∫£i n√∫t l√°, t√¨m n√∫t con ƒë·ªÉ ch√®n
            while (i >= 0 && key < node.keys[i])
                i--;

            i++;

            // N·∫øu n√∫t con ƒë·∫ßy, t√°ch n√≥ tr∆∞·ªõc
            if (node.children[i].n == 2 * t - 1) {
                splitChild(node, i);

                // Sau khi t√°ch, kh√≥a ·ªü gi·ªØa ƒë∆∞·ª£c ƒë·∫©y l√™n
                // X√°c ƒë·ªãnh l·∫°i n√∫t con c·∫ßn ch√®n
                if (key > node.keys[i])
                    i++;
            }

            insertNonFull(node.children[i], key);
        }
    }

    // T√°ch n√∫t con th·ª© i c·ªßa node
    private void splitChild(BPlusTreeNode parent, int i) {
        BPlusTreeNode child = parent.children[i];
        BPlusTreeNode newChild = new BPlusTreeNode(t, child.isLeaf);

        // Sao ch√©p n·ª≠a sau c·ªßa kh√≥a t·ª´ child sang newChild
        for (int j = 0; j < t - 1; j++)
            newChild.keys[j] = child.keys[j + t];

        // Sao ch√©p n·ª≠a sau c·ªßa con t·ª´ child sang newChild n·∫øu kh√¥ng ph·∫£i n√∫t l√°
        if (!child.isLeaf) {
            for (int j = 0; j < t; j++)
                newChild.children[j] = child.children[j + t];
        }

        // C·∫≠p nh·∫≠t s·ªë kh√≥a
        newChild.n = t - 1;
        child.n = t;

        // D·ªãch chuy·ªÉn con c·ªßa parent ƒë·ªÉ ch√®n newChild
        for (int j = parent.n; j > i; j--)
            parent.children[j + 1] = parent.children[j];

        parent.children[i + 1] = newChild;

        // D·ªãch chuy·ªÉn kh√≥a c·ªßa parent
        for (int j = parent.n - 1; j >= i; j--)
            parent.keys[j + 1] = parent.keys[j];

        // Kh√≥a ·ªü gi·ªØa c·ªßa child ƒë∆∞·ª£c ƒë·∫©y l√™n parent
        parent.keys[i] = child.keys[t - 1];

        parent.n++;

        // Thi·∫øt l·∫≠p li√™n k·∫øt gi·ªØa c√°c n√∫t l√°
        if (child.isLeaf) {
            newChild.next = child.next;
            child.next = newChild;

            // Trong c√¢y B+, ch√∫ng ta gi·ªØ l·∫°i kh√≥a trong n√∫t l√°
            child.keys[t - 1] = child.keys[t - 1]; // Gi·ªØ l·∫°i kh√≥a ·ªü n√∫t l√°
        }
    }

    // Duy·ªát c√¢y theo th·ª© t·ª±
    public void traverse() {
        if (root != null) {
            traverseInternal(root);
        }
    }

    private void traverseInternal(BPlusTreeNode node) {
        if (node.isLeaf) {
            for (int i = 0; i < node.n; i++) {
                System.out.print(node.keys[i] + " ");
            }
        } else {
            int i;
            for (i = 0; i < node.n; i++) {
                traverseInternal(node.children[i]);
                System.out.print(node.keys[i] + " ");
            }
            traverseInternal(node.children[i]);
        }
    }

    // Duy·ªát qua c√°c n√∫t l√° (theo th·ª© t·ª±)
    public void traverseLeaves() {
        BPlusTreeNode current = findLeftmostLeaf(root);

        while (current != null) {
            for (int i = 0; i < current.n; i++) {
                System.out.print(current.keys[i] + " ");
            }
            current = current.next;
        }
        System.out.println();
    }

    // T√¨m n√∫t l√° tr√°i nh·∫•t
    private BPlusTreeNode findLeftmostLeaf(BPlusTreeNode node) {
        if (node == null)
            return null;

        if (node.isLeaf)
            return node;

        return findLeftmostLeaf(node.children[0]);
    }

    // T√¨m kho·∫£ng gi√° tr·ªã [start, end]
    public List<Integer> rangeSearch(int start, int end) {
        List<Integer> result = new ArrayList<>();

        if (root == null)
            return result;

        BPlusTreeNode startLeaf = findLeafNode(root, start);

        // Duy·ªát qua c√°c n√∫t l√° v√† thu th·∫≠p c√°c kh√≥a trong kho·∫£ng
        BPlusTreeNode current = startLeaf;
        boolean found = false;

        while (current != null) {
            for (int i = 0; i < current.n; i++) {
                if (current.keys[i] >= start && current.keys[i] <= end) {
                    result.add(current.keys[i]);
                    found = true;
                } else if (found && current.keys[i] > end) {
                    // ƒê√£ v∆∞·ª£t qu√° kho·∫£ng, d·ª´ng t√¨m ki·∫øm
                    return result;
                }
            }
            current = current.next;
        }

        return result;
    }
}
```

## üßë‚Äçüè´ B√†i 3: Heap v√† Priority Queue

### C·∫•u tr√∫c Heap

Heap l√† m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu d·∫°ng c√¢y th·ªèa m√£n t√≠nh ch·∫•t heap: n√∫t cha lu√¥n l·ªõn h∆°n ho·∫∑c b·∫±ng (Max Heap) ho·∫∑c nh·ªè h∆°n ho·∫∑c b·∫±ng (Min Heap) c√°c n√∫t con.

- T√≠nh ch·∫•t c·ªßa Heap:
  - Heap l√† c√¢y nh·ªã ph√¢n ho√†n ch·ªânh: t·∫•t c·∫£ c√°c m·ª©c ƒë·ªÅu ƒë∆∞·ª£c l·∫•p ƒë·∫ßy tr·ª´ m·ª©c cu·ªëi c√πng, v√† c√°c n√∫t ·ªü m·ª©c cu·ªëi c√πng lu√¥n ƒë∆∞·ª£c ƒë·∫∑t t·ª´ tr√°i sang ph·∫£i.
  - C√°c n√∫t cha lu√¥n l·ªõn h∆°n ho·∫∑c b·∫±ng c√°c n√∫t con (trong Max-Heap).
  - C√°c n√∫t cha lu√¥n nh·ªè h∆°n ho·∫∑c b·∫±ng c√°c n√∫t con (trong Min-Heap).
  - Chi·ªÅu cao c·ªßa heap v·ªõi n ph·∫ßn t·ª≠ lu√¥n l√† O(log n).

### C√†i ƒë·∫∑t Heap

Heap th∆∞·ªùng ƒë∆∞·ª£c c√†i ƒë·∫∑t b·∫±ng m·∫£ng. V·ªõi node ·ªü v·ªã tr√≠ `i`:

- Con tr√°i ·ªü v·ªã tr√≠ `2*i + 1`
- Con ph·∫£i ·ªü v·ªã tr√≠ `2*i + 2`
- Cha ·ªü v·ªã tr√≠ `(i-1)/2`

#### Max Heap

```java
public class MaxHeap {
    private int[] heap;
    private int size;
    private int capacity;

    public MaxHeap(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.heap = new int[capacity];
    }

    private int parent(int i) {
        return (i - 1) / 2;
    }

    private int leftChild(int i) {
        return 2 * i + 1;
    }

    private int rightChild(int i) {
        return 2 * i + 2;
    }

    private void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }

    // Ch√®n m·ªôt ph·∫ßn t·ª≠ m·ªõi v√†o heap
    public void insert(int key) {
        if (size == capacity) {
            System.out.println("Heap ƒë√£ ƒë·∫ßy");
            return;
        }

        // Ch√®n v√†o cu·ªëi r·ªìi s√†ng l√™n
        size++;
        int i = size - 1;
        heap[i] = key;

        // S√†ng l√™n ƒë·ªÉ duy tr√¨ t√≠nh ch·∫•t c·ªßa heap
        while (i != 0 && heap[parent(i)] < heap[i]) {
            swap(i, parent(i));
            i = parent(i);
        }
    }

    // S√†ng xu·ªëng t·ª´ v·ªã tr√≠ i
    private void heapify(int i) {
        int left = leftChild(i);
        int right = rightChild(i);
        int largest = i;

        if (left < size && heap[left] > heap[largest])
            largest = left;

        if (right < size && heap[right] > heap[largest])
            largest = right;

        if (largest != i) {
            swap(i, largest);
            heapify(largest);
        }
    }

    // L·∫•y gi√° tr·ªã l·ªõn nh·∫•t
    public int extractMax() {
        if (size <= 0)
            throw new RuntimeException("Heap r·ªóng");

        if (size == 1) {
            size--;
            return heap[0];
        }

        int root = heap[0];
        heap[0] = heap[size - 1];
        size--;
        heapify(0);

        return root;
    }

    // TƒÉng gi√° tr·ªã c·ªßa ph·∫ßn t·ª≠
    public void increaseKey(int i, int newValue) {
        if (newValue < heap[i])
            throw new RuntimeException("Gi√° tr·ªã m·ªõi nh·ªè h∆°n gi√° tr·ªã hi·ªán t·∫°i");

        heap[i] = newValue;
        while (i != 0 && heap[parent(i)] < heap[i]) {
            swap(i, parent(i));
            i = parent(i);
        }
    }

    // X√≥a ph·∫ßn t·ª≠ t·∫°i v·ªã tr√≠ i
    public void delete(int i) {
        increaseKey(i, Integer.MAX_VALUE);
        extractMax();
    }

    public void printHeap() {
        for (int i = 0; i < size; i++) {
            System.out.print(heap[i] + " ");
        }
        System.out.println();
    }
}
```

#### Min Heap

```java
public class MinHeap {
    private int[] heap;
    private int size;
    private int capacity;

    public MinHeap(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.heap = new int[capacity];
    }

    private int parent(int i) {
        return (i - 1) / 2;
    }

    private int leftChild(int i) {
        return 2 * i + 1;
    }

    private int rightChild(int i) {
        return 2 * i + 2;
    }

    private void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }

    // Ch√®n m·ªôt ph·∫ßn t·ª≠ m·ªõi v√†o heap
    public void insert(int key) {
        if (size == capacity) {
            System.out.println("Heap ƒë√£ ƒë·∫ßy");
            return;
        }

        // Ch√®n v√†o cu·ªëi r·ªìi s√†ng l√™n
        size++;
        int i = size - 1;
        heap[i] = key;

        // S√†ng l√™n ƒë·ªÉ duy tr√¨ t√≠nh ch·∫•t c·ªßa heap
        while (i != 0 && heap[parent(i)] > heap[i]) {
            swap(i, parent(i));
            i = parent(i);
        }
    }

    // S√†ng xu·ªëng t·ª´ v·ªã tr√≠ i
    private void heapify(int i) {
        int left = leftChild(i);
        int right = rightChild(i);
        int smallest = i;

        if (left < size && heap[left] < heap[smallest])
            smallest = left;

        if (right < size && heap[right] < heap[smallest])
            smallest = right;

        if (smallest != i) {
            swap(i, smallest);
            heapify(smallest);
        }
    }

    // L·∫•y gi√° tr·ªã nh·ªè nh·∫•t
    public int extractMin() {
        if (size <= 0)
            throw new RuntimeException("Heap r·ªóng");

        if (size == 1) {
            size--;
            return heap[0];
        }

        int root = heap[0];
        heap[0] = heap[size - 1];
        size--;
        heapify(0);

        return root;
    }

    // Gi·∫£m gi√° tr·ªã c·ªßa ph·∫ßn t·ª≠
    public void decreaseKey(int i, int newValue) {
        if (newValue > heap[i])
            throw new RuntimeException("Gi√° tr·ªã m·ªõi l·ªõn h∆°n gi√° tr·ªã hi·ªán t·∫°i");

        heap[i] = newValue;
        while (i != 0 && heap[parent(i)] > heap[i]) {
            swap(i, parent(i));
            i = parent(i);
        }
    }

    // X√≥a ph·∫ßn t·ª≠ t·∫°i v·ªã tr√≠ i
    public void delete(int i) {
        decreaseKey(i, Integer.MIN_VALUE);
        extractMin();
    }

    public void printHeap() {
        for (int i = 0; i < size; i++) {
            System.out.print(heap[i] + " ");
        }
        System.out.println();
    }
}
```

### Priority Queue

Priority Queue (H√†ng ƒë·ª£i ∆∞u ti√™n) l√† m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu cho ph√©p:

- Ch√®n ph·∫ßn t·ª≠ v·ªõi ƒë·ªô ∆∞u ti√™n
- L·∫•y ra ph·∫ßn t·ª≠ c√≥ ƒë·ªô ∆∞u ti√™n cao nh·∫•t

#### C√†i ƒë·∫∑t Priority Queue s·ª≠ d·ª•ng Heap

```java
public class PriorityQueue<T extends Comparable<T>> {
    private class Node {
        T data;
        int priority;

        Node(T data, int priority) {
            this.data = data;
            this.priority = priority;
        }
    }

    private Node[] heap;
    private int size;
    private int capacity;

    @SuppressWarnings("unchecked")
    public PriorityQueue(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.heap = new Node[capacity];
    }

    private int parent(int i) {
        return (i - 1) / 2;
    }

    private int leftChild(int i) {
        return 2 * i + 1;
    }

    private int rightChild(int i) {
        return 2 * i + 2;
    }

    private void swap(int i, int j) {
        Node temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }

    // Ki·ªÉm tra xem h√†ng ƒë·ª£i c√≥ r·ªóng kh√¥ng
    public boolean isEmpty() {
        return size == 0;
    }

    // Ki·ªÉm tra xem h√†ng ƒë·ª£i c√≥ ƒë·∫ßy kh√¥ng
    public boolean isFull() {
        return size == capacity;
    }

    // Ch√®n m·ªôt ph·∫ßn t·ª≠ v√†o h√†ng ƒë·ª£i v·ªõi ƒë·ªô ∆∞u ti√™n
    public void enqueue(T data, int priority) {
        if (isFull()) {
            System.out.println("H√†ng ƒë·ª£i ƒë√£ ƒë·∫ßy");
            return;
        }

        // T·∫°o n√∫t m·ªõi v√† ch√®n v√†o cu·ªëi
        Node newNode = new Node(data, priority);
        heap[size] = newNode;
        size++;

        // S√†ng l√™n ƒë·ªÉ duy tr√¨ t√≠nh ch·∫•t c·ªßa heap
        int i = size - 1;
        while (i > 0 && heap[parent(i)].priority < heap[i].priority) {
            swap(i, parent(i));
            i = parent(i);
        }
    }

    // L·∫•y ph·∫ßn t·ª≠ c√≥ ƒë·ªô ∆∞u ti√™n cao nh·∫•t
    public T dequeue() {
        if (isEmpty()) {
            throw new RuntimeException("H√†ng ƒë·ª£i r·ªóng");
        }

        Node root = heap[0];
        heap[0] = heap[size - 1];
        size--;

        heapify(0);

        return root.data;
    }

    // Xem ph·∫ßn t·ª≠ c√≥ ƒë·ªô ∆∞u ti√™n cao nh·∫•t m√† kh√¥ng x√≥a
    public T peek() {
        if (isEmpty()) {
            throw new RuntimeException("H√†ng ƒë·ª£i r·ªóng");
        }
        return heap[0].data;
    }

    // S√†ng xu·ªëng t·ª´ v·ªã tr√≠ i
    private void heapify(int i) {
        int left = leftChild(i);
        int right = rightChild(i);
        int highest = i;

        if (left < size && heap[left].priority > heap[highest].priority)
            highest = left;

        if (right < size && heap[right].priority > heap[highest].priority)
            highest = right;

        if (highest != i) {
            swap(i, highest);
            heapify(highest);
        }
    }
}
```

### Heap Sort

Heap Sort l√† m·ªôt thu·∫≠t to√°n s·∫Øp x·∫øp hi·ªáu qu·∫£ d·ª±a tr√™n c·∫•u tr√∫c heap.

```java
public class HeapSort {
    public void sort(int[] arr) {
        int n = arr.length;

        // X√¢y d·ª±ng heap (s·∫Øp x·∫øp l·∫°i m·∫£ng)
        for (int i = n/2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }

        // Tr√≠ch xu·∫•t t·ª´ng ph·∫ßn t·ª≠ t·ª´ heap
        for (int i = n-1; i >= 0; i--) {
            // Di chuy·ªÉn root hi·ªán t·∫°i ƒë·∫øn cu·ªëi
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            // G·ªçi heapify tr√™n heap ƒë√£ gi·∫£m k√≠ch th∆∞·ªõc
            heapify(arr, i, 0);
        }
    }

    // ƒê·ªÉ s√†ng xu·ªëng m·ªôt subtree c√≥ root t·∫°i node i
    void heapify(int[] arr, int n, int i) {
        int largest = i; // Kh·ªüi t·∫°o largest l√† root
        int left = 2*i + 1;
        int right = 2*i + 2;

        // N·∫øu con tr√°i l·ªõn h∆°n root
        if (left < n && arr[left] > arr[largest])
            largest = left;

        // N·∫øu con ph·∫£i l·ªõn h∆°n largest hi·ªán t·∫°i
        if (right < n && arr[right] > arr[largest])
            largest = right;

        // N·∫øu largest kh√¥ng ph·∫£i root
        if (largest != i) {
            int swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;

            // Ti·∫øp t·ª•c heapify subtree b·ªã ·∫£nh h∆∞·ªüng
            heapify(arr, n, largest);
        }
    }
}
```

### 5. ·ª®ng d·ª•ng c·ªßa Heap v√† Priority Queue

1. **Gi·∫£i thu·∫≠t Dijkstra**: T√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t trong ƒë·ªì th·ªã.
2. **Gi·∫£i thu·∫≠t Prim**: T√¨m c√¢y khung nh·ªè nh·∫•t trong ƒë·ªì th·ªã.
3. **H·ªá th·ªëng qu·∫£n l√Ω t√°c v·ª•**: X·ª≠ l√Ω t√°c v·ª• theo ƒë·ªô ∆∞u ti√™n.
4. **Thu·∫≠t to√°n n√©n Huffman**: X√¢y d·ª±ng c√¢y Huffman s·ª≠ d·ª•ng min-heap.
5. **Heap Sort**: Thu·∫≠t to√°n s·∫Øp x·∫øp v·ªõi ƒë·ªô ph·ª©c t·∫°p O(n log n).
6. **T√¨m k ph·∫ßn t·ª≠ l·ªõn nh·∫•t/nh·ªè nh·∫•t**: S·ª≠ d·ª•ng min-heap ho·∫∑c max-heap.

### 6. B√†i t·∫≠p

#### B√†i t·∫≠p 1: C√†i ƒë·∫∑t thu·∫≠t to√°n t√¨m k ph·∫ßn t·ª≠ l·ªõn nh·∫•t trong m·ªôt m·∫£ng s·ª≠ d·ª•ng min-heap

```java
public static int[] findKLargest(int[] nums, int k) {
    // T·∫°o min-heap v·ªõi k√≠ch th∆∞·ªõc k
    PriorityQueue<Integer> minHeap = new PriorityQueue<>(k);

    // Th√™m k ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n v√†o heap
    for (int i = 0; i < k; i++) {
        minHeap.add(nums[i]);
    }

    // So s√°nh v√† thay th·∫ø c√°c ph·∫ßn t·ª≠ c√≤n l·∫°i
    for (int i = k; i < nums.length; i++) {
        if (nums[i] > minHeap.peek()) {
            minHeap.poll(); // Lo·∫°i b·ªè ph·∫ßn t·ª≠ nh·ªè nh·∫•t
            minHeap.add(nums[i]); // Th√™m ph·∫ßn t·ª≠ m·ªõi
        }
    }

    // Chuy·ªÉn k·∫øt qu·∫£ t·ª´ heap sang m·∫£ng
    int[] result = new int[k];
    for (int i = k-1; i >= 0; i--) {
        result[i] = minHeap.poll();
    }

    return result;
}
```

#### B√†i t·∫≠p 2: S·ª≠ d·ª•ng priority queue ƒë·ªÉ l·∫≠p l·ªãch CPU (x·ª≠ l√Ω c√°c ti·∫øn tr√¨nh theo ƒë·ªô ∆∞u ti√™n)

```java
class Process {
    String name;
    int priority;
    int burstTime;

    Process(String name, int priority, int burstTime) {
        this.name = name;
        this.priority = priority;
        this.burstTime = burstTime;
    }
}

public class CPUScheduler {
    public static void schedule(Process[] processes) {
        // T·∫°o priority queue d·ª±a tr√™n ƒë·ªô ∆∞u ti√™n c·ªßa ti·∫øn tr√¨nh
        PriorityQueue<Process> queue = new PriorityQueue<>(
            (p1, p2) -> p2.priority - p1.priority
        );

        // Th√™m t·∫•t c·∫£ ti·∫øn tr√¨nh v√†o queue
        for (Process process : processes) {
            queue.add(process);
        }

        // X·ª≠ l√Ω c√°c ti·∫øn tr√¨nh theo th·ª© t·ª± ƒë·ªô ∆∞u ti√™n
        System.out.println("L·ªãch CPU:");
        while (!queue.isEmpty()) {
            Process process = queue.poll();
            System.out.println("X·ª≠ l√Ω ti·∫øn tr√¨nh: " + process.name +
                              " (ƒê·ªô ∆∞u ti√™n: " + process.priority +
                              ", Th·ªùi gian x·ª≠ l√Ω: " + process.burstTime + ")");
        }
    }

    public static void main(String[] args) {
        Process[] processes = {
            new Process("P1", 10, 5),
            new Process("P2", 15, 3),
            new Process("P3", 7, 8),
            new Process("P4", 12, 2)
        };

        schedule(processes);
    }
}
```

### 7. Ph√¢n t√≠ch hi·ªáu nƒÉng

| Thao t√°c             | Th·ªùi gian trung b√¨nh | Th·ªùi gian x·∫•u nh·∫•t |
| -------------------- | -------------------- | ------------------ |
| Ch√®n                 | O(1)                 | O(log n)           |
| X√≥a t·ªëi ƒëa/t·ªëi thi·ªÉu | O(log n)             | O(log n)           |
| X√¢y d·ª±ng heap        | O(n)                 | O(n)               |
| TƒÉng/gi·∫£m kh√≥a       | O(log n)             | O(log n)           |
| T√¨m t·ªëi ƒëa/t·ªëi thi·ªÉu | O(1)                 | O(1)               |
| X√≥a                  | O(log n)             | O(log n)           |

Heap l√† c·∫•u tr√∫c d·ªØ li·ªáu tuy·ªát v·ªùi cho c√°c b√†i to√°n c·∫ßn truy xu·∫•t ph·∫ßn t·ª≠ l·ªõn nh·∫•t/nh·ªè nh·∫•t nhanh ch√≥ng v√† c·∫ßn thay ƒë·ªïi t·∫≠p d·ªØ li·ªáu th∆∞·ªùng xuy√™n.

## üßë‚Äçüè´ B√†i 4: Trie v√† ·ª©ng d·ª•ng

### C·∫•u tr√∫c d·ªØ li·ªáu Trie

Trie (hay c√¢y ti·ªÅn t·ªë) l√† m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu d·∫°ng c√¢y ƒë∆∞·ª£c d√πng ƒë·ªÉ l∆∞u tr·ªØ v√† t√¨m ki·∫øm c√°c chu·ªói k√Ω t·ª± m·ªôt c√°ch hi·ªáu qu·∫£.

#### ƒê·∫∑c ƒëi·ªÉm c·ªßa Trie

- M·ªói n√∫t trong trie c√≥ th·ªÉ l∆∞u tr·ªØ nhi·ªÅu con tr·ªè ƒë·∫øn c√°c n√∫t con (th∆∞·ªùng l√† 26 con tr·ªè cho c√°c ch·ªØ c√°i ti·∫øng Anh)
- ƒê∆∞·ªùng ƒëi t·ª´ g·ªëc ƒë·∫øn m·ªôt n√∫t bi·ªÉu di·ªÖn m·ªôt ti·ªÅn t·ªë (prefix)
- C√°c n√∫t l√° ho·∫∑c n√∫t ƒë∆∞·ª£c ƒë√°nh d·∫•u ƒë·∫∑c bi·ªát bi·ªÉu di·ªÖn m·ªôt t·ª´/chu·ªói ho√†n ch·ªânh
- T·∫•t c·∫£ c√°c n√∫t con c·ªßa m·ªôt n√∫t ƒë·ªÅu c√≥ ti·ªÅn t·ªë chung

#### C·∫•u tr√∫c n√∫t c·ªßa Trie

```java
class TrieNode {
    boolean isEndOfWord; // ƒê√°nh d·∫•u k·∫øt th√∫c c·ªßa m·ªôt t·ª´
    TrieNode[] children; // C√°c n√∫t con, th∆∞·ªùng l√† 26 cho 'a' ƒë·∫øn 'z'

    public TrieNode() {
        isEndOfWord = false;
        children = new TrieNode[26]; // Cho 26 ch·ªØ c√°i ti·∫øng Anh
        for (int i = 0; i < 26; i++)
            children[i] = null;
    }
}
```

### C√†i ƒë·∫∑t c∆° b·∫£n c·ªßa Trie

```java
public class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    // Ch√®n m·ªôt t·ª´ v√†o trie
    public void insert(String word) {
        TrieNode current = root;

        for (int i = 0; i < word.length(); i++) {
            int index = word.charAt(i) - 'a';
            if (current.children[index] == null)
                current.children[index] = new TrieNode();

            current = current.children[index];
        }

        // ƒê√°nh d·∫•u n√∫t cu·ªëi c√πng l√† k·∫øt th√∫c c·ªßa t·ª´
        current.isEndOfWord = true;
    }

    // T√¨m ki·∫øm m·ªôt t·ª´ trong trie
    public boolean search(String word) {
        TrieNode current = root;

        for (int i = 0; i < word.length(); i++) {
            int index = word.charAt(i) - 'a';
            if (current.children[index] == null)
                return false;

            current = current.children[index];
        }

        return current.isEndOfWord;
    }

    // Ki·ªÉm tra xem c√≥ t·ª´ n√†o b·∫Øt ƒë·∫ßu b·∫±ng ti·ªÅn t·ªë prefix kh√¥ng
    public boolean startsWith(String prefix) {
        TrieNode current = root;

        for (int i = 0; i < prefix.length(); i++) {
            int index = prefix.charAt(i) - 'a';
            if (current.children[index] == null)
                return false;

            current = current.children[index];
        }

        return true;
    }

    // X√≥a m·ªôt t·ª´ kh·ªèi trie
    public void delete(String word) {
        delete(root, word, 0);
    }

    private boolean delete(TrieNode current, String word, int index) {
        if (index == word.length()) {
            // N·∫øu t·ª´ kh√¥ng t·ªìn t·∫°i
            if (!current.isEndOfWord) {
                return false;
            }

            // ƒê√°nh d·∫•u t·ª´ ƒë√£ b·ªã x√≥a
            current.isEndOfWord = false;

            // Tr·∫£ v·ªÅ true n·∫øu n√∫t kh√¥ng c√≥ con n√†o
            return hasNoChildren(current);
        }

        int charIndex = word.charAt(index) - 'a';
        TrieNode child = current.children[charIndex];

        if (child == null) {
            return false; // T·ª´ kh√¥ng t·ªìn t·∫°i
        }

        boolean shouldDeleteChild = delete(child, word, index + 1);

        // N·∫øu c·∫ßn x√≥a n√∫t con v√† n√∫t con kh√¥ng ph·∫£i k·∫øt th√∫c c·ªßa t·ª´ kh√°c
        if (shouldDeleteChild) {
            current.children[charIndex] = null;

            // Tr·∫£ v·ªÅ true n·∫øu n√∫t hi·ªán t·∫°i kh√¥ng c√≥ t·ª´ n√†o k·∫øt th√∫c t·∫°i ƒë√≥
            // v√† kh√¥ng c√≥ con n√†o
            return !current.isEndOfWord && hasNoChildren(current);
        }

        return false;
    }

    private boolean hasNoChildren(TrieNode node) {
        for (int i = 0; i < 26; i++) {
            if (node.children[i] != null)
                return false;
        }
        return true;
    }
}
```

### ·ª®ng d·ª•ng c·ªßa Trie

#### T·ª± ƒë·ªông ho√†n th√†nh (Autocomplete)

```java
// C√†i ƒë·∫∑t t√≠nh nƒÉng t·ª± ƒë·ªông ho√†n th√†nh
public List<String> autocomplete(String prefix) {
    List<String> result = new ArrayList<>();
    TrieNode current = root;

    // Duy·ªát ƒë·∫øn n√∫t cu·ªëi c·ªßa ti·ªÅn t·ªë
    for (int i = 0; i < prefix.length(); i++) {
        int index = prefix.charAt(i) - 'a';
        if (current.children[index] == null)
            return result; // Kh√¥ng c√≥ t·ª´ n√†o b·∫Øt ƒë·∫ßu b·∫±ng ti·ªÅn t·ªë n√†y

        current = current.children[index];
    }

    // T√¨m t·∫•t c·∫£ c√°c t·ª´ b·∫Øt ƒë·∫ßu b·∫±ng ti·ªÅn t·ªë
    findAllWords(current, prefix, result);

    return result;
}

private void findAllWords(TrieNode node, String prefix, List<String> result) {
    // N·∫øu n√∫t hi·ªán t·∫°i l√† k·∫øt th√∫c c·ªßa m·ªôt t·ª´, th√™m t·ª´ v√†o k·∫øt qu·∫£
    if (node.isEndOfWord) {
        result.add(prefix);
    }

    // Duy·ªát qua t·∫•t c·∫£ c√°c con
    for (int i = 0; i < 26; i++) {
        if (node.children[i] != null) {
            char ch = (char) (i + 'a');
            findAllWords(node.children[i], prefix + ch, result);
        }
    }
}
```

#### Ki·ªÉm tra ti·ªÅn t·ªë (Prefix checking)

```java
// Ki·ªÉm tra xem m·ªôt t·ª´ c√≥ ph·∫£i l√† ti·ªÅn t·ªë c·ªßa b·∫•t k·ª≥ t·ª´ n√†o trong t·ª´ ƒëi·ªÉn
public boolean isPrefix(String word) {
    TrieNode current = root;

    for (int i = 0; i < word.length(); i++) {
        int index = word.charAt(i) - 'a';
        if (current.children[index] == null)
            return false;

        current = current.children[index];
    }

    return true;
}
```

#### T√¨m ki·∫øm t·ª´ trong ma tr·∫≠n (Word Search)

```java
public boolean exist(char[][] board, String word) {
    if (board == null || board.length == 0 || word == null)
        return false;

    int m = board.length;
    int n = board[0].length;
    boolean[][] visited = new boolean[m][n];

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (board[i][j] == word.charAt(0) && search(board, word, i, j, 0, visited))
                return true;
        }
    }

    return false;
}

private boolean search(char[][] board, String word, int i, int j, int index, boolean[][] visited) {
    // N·∫øu ƒë√£ t√¨m th·∫•y t·∫•t c·∫£ c√°c k√Ω t·ª±
    if (index == word.length())
        return true;

    // Ki·ªÉm tra bi√™n v√† k√Ω t·ª±
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length ||
        board[i][j] != word.charAt(index) || visited[i][j])
        return false;

    // ƒê√°nh d·∫•u √¥ ƒë√£ thƒÉm
    visited[i][j] = true;

    // Ki·ªÉm tra 4 h∆∞·ªõng
    boolean result = search(board, word, i+1, j, index+1, visited) ||
                     search(board, word, i-1, j, index+1, visited) ||
                     search(board, word, i, j+1, index+1, visited) ||
                     search(board, word, i, j-1, index+1, visited);

    // B·ªè ƒë√°nh d·∫•u
    visited[i][j] = false;

    return result;
}
```

#### T·ª´ ƒëi·ªÉn (Dictionary)

```java
public class Dictionary {
    private Trie trie;

    public Dictionary() {
        trie = new Trie();
    }

    public void addWord(String word) {
        trie.insert(word.toLowerCase());
    }

    public boolean isValidWord(String word) {
        return trie.search(word.toLowerCase());
    }

    public List<String> getWordsStartingWith(String prefix) {
        return trie.autocomplete(prefix.toLowerCase());
    }

    public void removeWord(String word) {
        trie.delete(word.toLowerCase());
    }
}
```

### Trie v·ªõi b·∫£ng bƒÉm (Hash Trie)

```java
class HashTrieNode {
    boolean isEndOfWord;
    HashMap<Character, HashTrieNode> children;

    public HashTrieNode() {
        isEndOfWord = false;
        children = new HashMap<>();
    }
}

public class HashTrie {
    private HashTrieNode root;

    public HashTrie() {
        root = new HashTrieNode();
    }

    public void insert(String word) {
        HashTrieNode current = root;

        for (int i = 0; i < word.length(); i++) {
            char ch = word.charAt(i);
            HashTrieNode node = current.children.get(ch);
            if (node == null) {
                node = new HashTrieNode();
                current.children.put(ch, node);
            }
            current = node;
        }

        current.isEndOfWord = true;
    }

    public boolean search(String word) {
        HashTrieNode current = root;

        for (int i = 0; i < word.length(); i++) {
            char ch = word.charAt(i);
            HashTrieNode node = current.children.get(ch);
            if (node == null)
                return false;
            current = node;
        }

        return current.isEndOfWord;
    }

    public boolean startsWith(String prefix) {
        HashTrieNode current = root;

        for (int i = 0; i < prefix.length(); i++) {
            char ch = prefix.charAt(i);
            HashTrieNode node = current.children.get(ch);
            if (node == null)
                return false;
            current = node;
        }

        return true;
    }
}
```

### Trie n√©n (Compressed Trie)

```java
class CompressedTrieNode {
    String prefix;
    boolean isEndOfWord;
    HashMap<Character, CompressedTrieNode> children;

    public CompressedTrieNode(String prefix) {
        this.prefix = prefix;
        this.isEndOfWord = false;
        this.children = new HashMap<>();
    }
}

public class CompressedTrie {
    private CompressedTrieNode root;

    public CompressedTrie() {
        root = new CompressedTrieNode("");
    }

    public void insert(String word) {
        insert(root, word);
    }

    private void insert(CompressedTrieNode node, String word) {
        // N·∫øu t·ª´ r·ªóng, ƒë√°nh d·∫•u n√∫t hi·ªán t·∫°i l√† k·∫øt th√∫c t·ª´
        if (word.isEmpty()) {
            node.isEndOfWord = true;
            return;
        }

        char firstChar = word.charAt(0);
        CompressedTrieNode child = node.children.get(firstChar);

        // N·∫øu kh√¥ng c√≥ n√∫t con b·∫Øt ƒë·∫ßu b·∫±ng k√Ω t·ª± n√†y
        if (child == null) {
            child = new CompressedTrieNode(word);
            node.children.put(firstChar, child);
            child.isEndOfWord = true;
            return;
        }

        // T√¨m ƒëi·ªÉm kh√°c nhau ƒë·∫ßu ti√™n gi·ªØa t·ª´ m·ªõi v√† ti·ªÅn t·ªë c·ªßa n√∫t con
        int i = 0;
        String childPrefix = child.prefix;
        while (i < word.length() && i < childPrefix.length() && word.charAt(i) == childPrefix.charAt(i)) {
            i++;
        }

        // N·∫øu t·ª´ m·ªõi l√† ti·ªÅn t·ªë c·ªßa n√∫t con
        if (i == word.length()) {
            // T√°ch n√∫t con
            CompressedTrieNode newChild = new CompressedTrieNode(childPrefix.substring(i));
            newChild.children = child.children;
            newChild.isEndOfWord = child.isEndOfWord;

            // C·∫≠p nh·∫≠t n√∫t con c≈©
            child.prefix = word;
            child.children = new HashMap<>();
            child.children.put(childPrefix.charAt(i), newChild);
            child.isEndOfWord = true;
        }
        // N·∫øu n√∫t con l√† ti·ªÅn t·ªë c·ªßa t·ª´ m·ªõi
        else if (i == childPrefix.length()) {
            insert(child, word.substring(i));
        }
        // N·∫øu t·ª´ m·ªõi v√† n√∫t con c√≥ ti·ªÅn t·ªë chung
        else {
            // T·∫°o n√∫t ti·ªÅn t·ªë chung
            CompressedTrieNode commonPrefixNode = new CompressedTrieNode(word.substring(0, i));
            node.children.put(firstChar, commonPrefixNode);

            // T·∫°o n√∫t cho ph·∫ßn c√≤n l·∫°i c·ªßa t·ª´ m·ªõi
            CompressedTrieNode newWordNode = new CompressedTrieNode(word.substring(i));
            newWordNode.isEndOfWord = true;

            // T·∫°o n√∫t cho ph·∫ßn c√≤n l·∫°i c·ªßa ti·ªÅn t·ªë n√∫t con
            CompressedTrieNode remainingPrefixNode = new CompressedTrieNode(childPrefix.substring(i));
            remainingPrefixNode.children = child.children;
            remainingPrefixNode.isEndOfWord = child.isEndOfWord;

            // Li√™n k·∫øt c√°c n√∫t
            commonPrefixNode.children.put(word.charAt(i), newWordNode);
            commonPrefixNode.children.put(childPrefix.charAt(i), remainingPrefixNode);
        }
    }

    public boolean search(String word) {
        return search(root, word);
    }

    private boolean search(CompressedTrieNode node, String word) {
        if (word.isEmpty())
            return node.isEndOfWord;

        char firstChar = word.charAt(0);
        CompressedTrieNode child = node.children.get(firstChar);

        if (child == null)
            return false;

        String childPrefix = child.prefix;

        // N·∫øu t·ª´ kh√¥ng b·∫Øt ƒë·∫ßu b·∫±ng ti·ªÅn t·ªë c·ªßa n√∫t con
        if (!word.startsWith(childPrefix))
            return false;

        // N·∫øu t·ª´ l√† ti·ªÅn t·ªë c·ªßa n√∫t con
        if (word.equals(childPrefix))
            return child.isEndOfWord;

        // Ki·ªÉm tra ph·∫ßn c√≤n l·∫°i c·ªßa t·ª´
        return search(child, word.substring(childPrefix.length()));
    }
}
```

### Ph√¢n t√≠ch hi·ªáu nƒÉng c·ªßa Trie

| Thao t√°c           | Th·ªùi gian | Kh√¥ng gian |
| ------------------ | --------- | ---------- |
| Ch√®n               | O(m)      | O(m)       |
| T√¨m ki·∫øm           | O(m)      | O(1)       |
| X√≥a                | O(m)      | O(1)       |
| Ti·ªÅn t·ªë            | O(p)      | O(1)       |
| Ho√†n th√†nh t·ª± ƒë·ªông | O(n)      | O(n)       |

Trong ƒë√≥:

- m l√† ƒë·ªô d√†i t·ª´ c·∫ßn ch√®n/t√¨m ki·∫øm/x√≥a
- p l√† ƒë·ªô d√†i ti·ªÅn t·ªë
- n l√† s·ªë t·ª´ trong Trie

### So s√°nh v·ªõi c√°c c·∫•u tr√∫c d·ªØ li·ªáu kh√°c

| C·∫•u tr√∫c d·ªØ li·ªáu   | ∆Øu ƒëi·ªÉm                     | Nh∆∞·ª£c ƒëi·ªÉm                        |
| ------------------ | --------------------------- | --------------------------------- |
| Trie               | - T√¨m ki·∫øm nhanh O(m)       | - T·ªën nhi·ªÅu b·ªô nh·ªõ                |
|                    | - T√¨m ti·ªÅn t·ªë hi·ªáu qu·∫£      | - C√†i ƒë·∫∑t ph·ª©c t·∫°p h∆°n            |
|                    | - H·ªó tr·ª£ t·ª± ƒë·ªông ho√†n th√†nh |                                   |
| Hash Table         | - T√¨m ki·∫øm nhanh O(1)       | - Kh√¥ng h·ªó tr·ª£ t√¨m ti·ªÅn t·ªë        |
|                    | - √çt t·ªën b·ªô nh·ªõ h∆°n         | - Kh√¥ng h·ªó tr·ª£ t·ª± ƒë·ªông ho√†n th√†nh |
| Binary Search Tree | - C√¢n b·∫±ng t·ªët v·ªÅ b·ªô nh·ªõ    | - T√¨m ki·∫øm ch·∫≠m h∆°n O(log n)      |
|                    | - D·ªÖ c√†i ƒë·∫∑t                | - Kh√¥ng hi·ªáu qu·∫£ cho t√¨m ti·ªÅn t·ªë  |

### B√†i t·∫≠p

#### B√†i t·∫≠p 1: ƒê·∫øm s·ªë t·ª´ c√≥ ti·ªÅn t·ªë chung

```java
public int countWordsWithPrefix(String prefix) {
    TrieNode current = root;

    // Duy·ªát ƒë·∫øn n√∫t cu·ªëi c·ªßa ti·ªÅn t·ªë
    for (int i = 0; i < prefix.length(); i++) {
        int index = prefix.charAt(i) - 'a';
        if (current.children[index] == null)
            return 0;

        current = current.children[index];
    }

    // ƒê·∫øm t·∫•t c·∫£ c√°c t·ª´ b·∫Øt ƒë·∫ßu t·ª´ n√∫t n√†y
    return countWords(current);
}

private int countWords(TrieNode node) {
    int count = 0;

    if (node.isEndOfWord)
        count++;

    for (int i = 0; i < 26; i++) {
        if (node.children[i] != null)
            count += countWords(node.children[i]);
    }

    return count;
}
```

#### B√†i t·∫≠p 2: T√¨m t·ª´ d√†i nh·∫•t c√≥ t·∫•t c·∫£ ti·ªÅn t·ªë trong t·ª´ ƒëi·ªÉn

```java
public String findLongestWordWithAllPrefixes() {
    return findLongestWord(root, "");
}

private String findLongestWord(TrieNode node, String prefix) {
    String maxWord = node.isEndOfWord ? prefix : "";

    for (int i = 0; i < 26; i++) {
        if (node.children[i] != null) {
            char ch = (char) (i + 'a');
            String word = findLongestWord(node.children[i], prefix + ch);

            // Ch·ªâ xem x√©t t·ª´ c√≥ t·∫•t c·∫£ ti·ªÅn t·ªë trong t·ª´ ƒëi·ªÉn
            if (word.length() > maxWord.length() &&
                allPrefixesExist(word))
                maxWord = word;
        }
    }

    return maxWord;
}

private boolean allPrefixesExist(String word) {
    for (int i = 1; i < word.length(); i++) {
        if (!search(word.substring(0, i)))
            return false;
    }
    return true;
}
```

#### B√†i t·∫≠p 3: X√¢y d·ª±ng tr√≤ ch∆°i t√¨m t·ª´ (Word Boggle)

```java
public List<String> findWords(char[][] board, String[] words) {
    List<String> result = new ArrayList<>();
    Trie trie = new Trie();

    // Th√™m t·∫•t c·∫£ c√°c t·ª´ v√†o trie
    for (String word : words)
        trie.insert(word);

    int m = board.length;
    int n = board[0].length;
    boolean[][] visited = new boolean[m][n];
    Set<String> foundWords = new HashSet<>();

    // Duy·ªát qua t·∫•t c·∫£ c√°c √¥ tr√™n b·∫£ng
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            findWordsUtil(board, i, j, trie.root, "", visited, foundWords);
        }
    }

    result.addAll(foundWords);
    return result;
}

private void findWordsUtil(char[][] board, int i, int j, TrieNode node,
                          String prefix, boolean[][] visited, Set<String> result) {
    // Ki·ªÉm tra bi√™n
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || visited[i][j])
        return;

    char ch = board[i][j];
    int index = ch - 'a';

    // N·∫øu kh√¥ng c√≥ n√∫t con cho k√Ω t·ª± n√†y
    if (node.children[index] == null)
        return;

    // C·∫≠p nh·∫≠t ti·ªÅn t·ªë v√† n√∫t
    prefix += ch;
    node = node.children[index];

    // N·∫øu ƒë√¢y l√† m·ªôt t·ª´ ho√†n ch·ªânh, th√™m v√†o k·∫øt qu·∫£
    if (node.isEndOfWord)
        result.add(prefix);

    // ƒê√°nh d·∫•u √¥ hi·ªán t·∫°i ƒë√£ thƒÉm
    visited[i][j] = true;

    // Duy·ªát 8 h∆∞·ªõng
    int[] dx = {-1, -1, -1, 0, 0, 1, 1, 1};
    int[] dy = {-1, 0, 1, -1, 1, -1, 0, 1};

    for (int k = 0; k < 8; k++) {
        findWordsUtil(board, i + dx[k], j + dy[k], node, prefix, visited, result);
    }

    // B·ªè ƒë√°nh d·∫•u √¥ hi·ªán t·∫°i
    visited[i][j] = false;
}
```

## üßë‚Äçüè´ B√†i 5: Segment Tree v√† Fenwick Tree

### Segment Tree

Segment Tree (C√¢y ph√¢n ƒëo·∫°n) l√† m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ gi·∫£i quy·∫øt c√°c b√†i to√°n truy v·∫•n kho·∫£ng v√† c·∫≠p nh·∫≠t c√°c ph·∫ßn t·ª≠ trong m·∫£ng m·ªôt c√°ch hi·ªáu qu·∫£.

#### T√≠nh ch·∫•t c·ªßa Segment Tree

- N√∫t g·ªëc ƒë·∫°i di·ªán cho to√†n b·ªô m·∫£ng
- M·ªói n√∫t l√° ƒë·∫°i di·ªán cho m·ªôt ph·∫ßn t·ª≠ ƒë∆°n l·∫ª
- M·ªói n√∫t n·ªôi b·ªô c√≥ hai n√∫t con, ƒë·∫°i di·ªán cho hai n·ª≠a ƒëo·∫°n c·ªßa n√∫t cha

#### C√†i ƒë·∫∑t Segment Tree

```java
public class SegmentTree {
    int[] tree;
    int n; // K√≠ch th∆∞·ªõc m·∫£ng ban ƒë·∫ßu

    // X√¢y d·ª±ng segment tree t·ª´ m·∫£ng ƒë·∫ßu v√†o
    public SegmentTree(int[] arr) {
        n = arr.length;
        // Chi·ªÅu cao c·ªßa c√¢y = ceil(log2(n))
        int height = (int) Math.ceil(Math.log(n) / Math.log(2));
        // S·ªë n√∫t t·ªëi ƒëa = 2*2^h - 1
        int maxSize = 2 * (int) Math.pow(2, height) - 1;

        tree = new int[maxSize];
        buildSegmentTree(arr, 0, n - 1, 0);
    }

    // H√†m x√¢y d·ª±ng segment tree
    private int buildSegmentTree(int[] arr, int start, int end, int index) {
        // N·∫øu l√† n√∫t l√° (start == end)
        if (start == end) {
            tree[index] = arr[start];
            return tree[index];
        }

        int mid = start + (end - start) / 2;

        // X√¢y d·ª±ng c√¢y con tr√°i v√† ph·∫£i
        int leftSum = buildSegmentTree(arr, start, mid, 2 * index + 1);
        int rightSum = buildSegmentTree(arr, mid + 1, end, 2 * index + 2);

        // T·ªïng c·ªßa ƒëo·∫°n hi·ªán t·∫°i l√† t·ªïng c·ªßa hai ƒëo·∫°n con
        tree[index] = leftSum + rightSum;

        return tree[index];
    }

    // Truy v·∫•n t·ªïng trong ƒëo·∫°n [qStart, qEnd]
    public int getSum(int qStart, int qEnd) {
        if (qStart < 0 || qEnd >= n || qStart > qEnd) {
            System.out.println("Truy v·∫•n kh√¥ng h·ª£p l·ªá");
            return -1;
        }

        return getSumUtil(0, n - 1, qStart, qEnd, 0);
    }

    private int getSumUtil(int start, int end, int qStart, int qEnd, int index) {
        // N·∫øu ƒëo·∫°n hi·ªán t·∫°i n·∫±m ho√†n to√†n trong ƒëo·∫°n truy v·∫•n
        if (qStart <= start && qEnd >= end)
            return tree[index];

        // N·∫øu ƒëo·∫°n hi·ªán t·∫°i n·∫±m ho√†n to√†n ngo√†i ƒëo·∫°n truy v·∫•n
        if (end < qStart || start > qEnd)
            return 0;

        // N·∫øu ƒëo·∫°n hi·ªán t·∫°i v√† ƒëo·∫°n truy v·∫•n giao nhau
        int mid = start + (end - start) / 2;

        int leftSum = getSumUtil(start, mid, qStart, qEnd, 2 * index + 1);
        int rightSum = getSumUtil(mid + 1, end, qStart, qEnd, 2 * index + 2);

        return leftSum + rightSum;
    }

    // C·∫≠p nh·∫≠t gi√° tr·ªã c·ªßa ph·∫ßn t·ª≠
    public void update(int pos, int newValue) {
        if (pos < 0 || pos >= n) {
            System.out.println("V·ªã tr√≠ kh√¥ng h·ª£p l·ªá");
            return;
        }

        // T√≠nh to√°n s·ª± ch√™nh l·ªách
        int diff = newValue - getSum(pos, pos);

        // C·∫≠p nh·∫≠t segment tree
        updateUtil(0, n - 1, pos, diff, 0);
    }

    private void updateUtil(int start, int end, int pos, int diff, int index) {
        // N·∫øu v·ªã tr√≠ c·∫ßn c·∫≠p nh·∫≠t kh√¥ng n·∫±m trong ƒëo·∫°n hi·ªán t·∫°i
        if (pos < start || pos > end)
            return;

        // C·∫≠p nh·∫≠t gi√° tr·ªã c·ªßa n√∫t hi·ªán t·∫°i
        tree[index] += diff;

        // N·∫øu kh√¥ng ph·∫£i n√∫t l√°, c·∫≠p nh·∫≠t c√°c n√∫t con
        if (start != end) {
            int mid = start + (end - start) / 2;

            updateUtil(start, mid, pos, diff, 2 * index + 1);
            updateUtil(mid + 1, end, pos, diff, 2 * index + 2);
        }
    }

    // C·∫≠p nh·∫≠t gi√° tr·ªã trong ƒëo·∫°n [uStart, uEnd]
    public void updateRange(int uStart, int uEnd, int diff) {
        if (uStart < 0 || uEnd >= n || uStart > uEnd) {
            System.out.println("Truy v·∫•n kh√¥ng h·ª£p l·ªá");
            return;
        }

        updateRangeUtil(0, n - 1, uStart, uEnd, diff, 0);
    }

    private void updateRangeUtil(int start, int end, int uStart, int uEnd, int diff, int index) {
        // N·∫øu ƒëo·∫°n hi·ªán t·∫°i n·∫±m ngo√†i ƒëo·∫°n c·∫≠p nh·∫≠t
        if (end < uStart || start > uEnd)
            return;

        // N·∫øu n√∫t l√°
        if (start == end) {
            tree[index] += diff;
            return;
        }

        // C·∫≠p nh·∫≠t c√¢y con
        int mid = start + (end - start) / 2;

        updateRangeUtil(start, mid, uStart, uEnd, diff, 2 * index + 1);
        updateRangeUtil(mid + 1, end, uStart, uEnd, diff, 2 * index + 2);

        // C·∫≠p nh·∫≠t n√∫t cha sau khi c·∫≠p nh·∫≠t c√°c n√∫t con
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
    }

    // T√¨m gi√° tr·ªã nh·ªè nh·∫•t trong ƒëo·∫°n [qStart, qEnd]
    public int getMin(int qStart, int qEnd) {
        if (qStart < 0 || qEnd >= n || qStart > qEnd) {
            System.out.println("Truy v·∫•n kh√¥ng h·ª£p l·ªá");
            return Integer.MAX_VALUE;
        }

        return getMinUtil(0, n - 1, qStart, qEnd, 0);
    }

    private int getMinUtil(int start, int end, int qStart, int qEnd, int index) {
        // N·∫øu ƒëo·∫°n hi·ªán t·∫°i n·∫±m ho√†n to√†n trong ƒëo·∫°n truy v·∫•n
        if (qStart <= start && qEnd >= end)
            return tree[index];

        // N·∫øu ƒëo·∫°n hi·ªán t·∫°i n·∫±m ho√†n to√†n ngo√†i ƒëo·∫°n truy v·∫•n
        if (end < qStart || start > qEnd)
            return Integer.MAX_VALUE;

        // N·∫øu ƒëo·∫°n hi·ªán t·∫°i v√† ƒëo·∫°n truy v·∫•n giao nhau
        int mid = start + (end - start) / 2;

        int leftMin = getMinUtil(start, mid, qStart, qEnd, 2 * index + 1);
        int rightMin = getMinUtil(mid + 1, end, qStart, qEnd, 2 * index + 2);

        return Math.min(leftMin, rightMin);
    }
}
```

### Lazy Propagation trong Segment Tree

Lazy Propagation l√† m·ªôt k·ªπ thu·∫≠t t·ªëi ∆∞u cho Segment Tree khi c√≥ nhi·ªÅu thao t√°c c·∫≠p nh·∫≠t tr√™n ƒëo·∫°n.

```java
public class LazySegmentTree {
    int[] tree;
    int[] lazy;
    int n;

    public LazySegmentTree(int[] arr) {
        n = arr.length;
        int height = (int) Math.ceil(Math.log(n) / Math.log(2));
        int maxSize = 2 * (int) Math.pow(2, height) - 1;

        tree = new int[maxSize];
        lazy = new int[maxSize]; // M·∫£ng lazy ƒë·ªÉ tr√¨ ho√£n c·∫≠p nh·∫≠t

        buildSegmentTree(arr, 0, n - 1, 0);
    }

    private int buildSegmentTree(int[] arr, int start, int end, int index) {
        if (start == end) {
            tree[index] = arr[start];
            return tree[index];
        }

        int mid = start + (end - start) / 2;
        int leftSum = buildSegmentTree(arr, start, mid, 2 * index + 1);
        int rightSum = buildSegmentTree(arr, mid + 1, end, 2 * index + 2);

        tree[index] = leftSum + rightSum;

        return tree[index];
    }

    // Truy v·∫•n t·ªïng v·ªõi lazy propagation
    public int getSum(int qStart, int qEnd) {
        if (qStart < 0 || qEnd >= n || qStart > qEnd) {
            return -1;
        }

        return getSumUtil(0, n - 1, qStart, qEnd, 0);
    }

    private int getSumUtil(int start, int end, int qStart, int qEnd, int index) {
        // Lan truy·ªÅn lazy c·∫≠p nh·∫≠t tr∆∞·ªõc khi truy v·∫•n
        if (lazy[index] != 0) {
            tree[index] += (end - start + 1) * lazy[index]; // C·∫≠p nh·∫≠t n√∫t hi·ªán t·∫°i

            if (start != end) { // N·∫øu kh√¥ng ph·∫£i n√∫t l√°
                lazy[2 * index + 1] += lazy[index]; // Lan truy·ªÅn xu·ªëng con tr√°i
                lazy[2 * index + 2] += lazy[index]; // Lan truy·ªÅn xu·ªëng con ph·∫£i
            }

            lazy[index] = 0; // ƒê√£ lan truy·ªÅn xong
        }

        // N·∫øu ƒëo·∫°n hi·ªán t·∫°i n·∫±m ho√†n to√†n ngo√†i ƒëo·∫°n truy v·∫•n
        if (end < qStart || start > qEnd)
            return 0;

        // N·∫øu ƒëo·∫°n hi·ªán t·∫°i n·∫±m ho√†n to√†n trong ƒëo·∫°n truy v·∫•n
        if (qStart <= start && qEnd >= end)
            return tree[index];

        // N·∫øu ƒëo·∫°n hi·ªán t·∫°i v√† ƒëo·∫°n truy v·∫•n giao nhau
        int mid = start + (end - start) / 2;

        int leftSum = getSumUtil(start, mid, qStart, qEnd, 2 * index + 1);
        int rightSum = getSumUtil(mid + 1, end, qStart, qEnd, 2 * index + 2);

        return leftSum + rightSum;
    }

    // C·∫≠p nh·∫≠t ƒëo·∫°n v·ªõi lazy propagation
    public void updateRange(int uStart, int uEnd, int diff) {
        if (uStart < 0 || uEnd >= n || uStart > uEnd) {
            System.out.println("Truy v·∫•n kh√¥ng h·ª£p l·ªá");
            return;
        }

        updateRangeUtil(0, n - 1, uStart, uEnd, diff, 0);
    }

    private void updateRangeUtil(int start, int end, int uStart, int uEnd, int diff, int index) {
        // Lan truy·ªÅn lazy c·∫≠p nh·∫≠t tr∆∞·ªõc khi c·∫≠p nh·∫≠t
        if (lazy[index] != 0) {
            tree[index] += (end - start + 1) * lazy[index];

            if (start != end) {
                lazy[2 * index + 1] += lazy[index];
                lazy[2 * index + 2] += lazy[index];
            }

            lazy[index] = 0;
        }

        // N·∫øu ƒëo·∫°n hi·ªán t·∫°i n·∫±m ngo√†i ƒëo·∫°n c·∫≠p nh·∫≠t
        if (end < uStart || start > uEnd)
            return;

        // N·∫øu ƒëo·∫°n hi·ªán t·∫°i n·∫±m ho√†n to√†n trong ƒëo·∫°n c·∫≠p nh·∫≠t
        if (uStart <= start && uEnd >= end) {
            tree[index] += (end - start + 1) * diff;

            if (start != end) {
                lazy[2 * index + 1] += diff;
                lazy[2 * index + 2] += diff;
            }

            return;
        }

        // N·∫øu ƒëo·∫°n hi·ªán t·∫°i v√† ƒëo·∫°n c·∫≠p nh·∫≠t giao nhau
        int mid = start + (end - start) / 2;

        updateRangeUtil(start, mid, uStart, uEnd, diff, 2 * index + 1);
        updateRangeUtil(mid + 1, end, uStart, uEnd, diff, 2 * index + 2);

        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
    }
}
```

### Fenwick Tree (Binary Indexed Tree)

Fenwick Tree ho·∫∑c Binary Indexed Tree l√† m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu hi·ªáu qu·∫£ cho c√°c thao t√°c c·∫≠p nh·∫≠t v√† truy v·∫•n t·ªïng ti·ªÅn t·ªë.

#### T√≠nh ch·∫•t c·ªßa Fenwick Tree

- S·ª≠ d·ª•ng bit cu·ªëi c√πng (LSB - Least Significant Bit) c·ªßa ch·ªâ s·ªë ƒë·ªÉ x√°c ƒë·ªãnh ph·∫°m vi ph·ª• tr√°ch c·ªßa m·ªói n√∫t
- Thao t√°c c·∫≠p nh·∫≠t v√† truy v·∫•n c√≥ ƒë·ªô ph·ª©c t·∫°p O(log n)
- Chi·∫øm √≠t b·ªô nh·ªõ h∆°n Segment Tree

#### C√†i ƒë·∫∑t Fenwick Tree

```java
public class FenwickTree {
    private int[] bit; // Binary Indexed Tree
    private int n;

    public FenwickTree(int n) {
        this.n = n;
        bit = new int[n + 1]; // Ch·ªâ s·ªë b·∫Øt ƒë·∫ßu t·ª´ 1
    }

    // X√¢y d·ª±ng BIT t·ª´ m·∫£ng ƒë·∫ßu v√†o
    public FenwickTree(int[] arr) {
        this.n = arr.length;
        bit = new int[n + 1];

        for (int i = 0; i < n; i++) {
            update(i, arr[i]);
        }
    }

    // C·∫≠p nh·∫≠t gi√° tr·ªã: th√™m val v√†o index
    public void update(int index, int val) {
        index++; // Chuy·ªÉn sang ch·ªâ s·ªë 1-based

        while (index <= n) {
            bit[index] += val;
            index += index & -index; // C·ªông v·ªõi bit cu·ªëi c√πng l√† 1
        }
    }

    // Truy v·∫•n t·ªïng ti·ªÅn t·ªë: t√≠nh t·ªïng t·ª´ arr[0] ƒë·∫øn arr[index]
    public int getSum(int index) {
        int sum = 0;
        index++; // Chuy·ªÉn sang ch·ªâ s·ªë 1-based

        while (index > 0) {
            sum += bit[index];
            index -= index & -index; // Tr·ª´ ƒëi bit cu·ªëi c√πng l√† 1
        }

        return sum;
    }

    // Truy v·∫•n t·ªïng trong ƒëo·∫°n [left, right]
    public int getSumRange(int left, int right) {
        return getSum(right) - getSum(left - 1);
    }

    // L·∫•y gi√° tr·ªã t·∫°i v·ªã tr√≠ index
    public int getValue(int index) {
        return getSumRange(index, index);
    }

    // T√¨m ch·ªâ s·ªë ƒë·∫ßu ti√™n sao cho t·ªïng ti·ªÅn t·ªë >= sum
    public int findIndex(int sum) {
        int index = 0;
        int bitMask = Integer.highestOneBit(n);

        while (bitMask != 0) {
            int tIndex = index + bitMask;

            bitMask >>= 1;

            if (tIndex > n) continue;

            if (sum == bit[tIndex]) return tIndex;

            if (sum > bit[tIndex]) {
                sum -= bit[tIndex];
                index = tIndex;
            }
        }

        return index + 1;
    }
}
```

### Fenwick Tree 2D

M·ªü r·ªông Fenwick Tree ƒë·ªÉ h·ªó tr·ª£ truy v·∫•n v√† c·∫≠p nh·∫≠t tr√™n ma tr·∫≠n 2D:

```java
public class FenwickTree2D {
    private int[][] bit;
    private int n, m; // K√≠ch th∆∞·ªõc ma tr·∫≠n

    public FenwickTree2D(int n, int m) {
        this.n = n;
        this.m = m;
        bit = new int[n + 1][m + 1]; // Ch·ªâ s·ªë b·∫Øt ƒë·∫ßu t·ª´ 1
    }

    // C·∫≠p nh·∫≠t gi√° tr·ªã t·∫°i v·ªã tr√≠ (x, y)
    public void update(int x, int y, int val) {
        x++; y++; // Chuy·ªÉn sang ch·ªâ s·ªë 1-based

        for (int i = x; i <= n; i += i & -i) {
            for (int j = y; j <= m; j += j & -j) {
                bit[i][j] += val;
            }
        }
    }

    // Truy v·∫•n t·ªïng t·ª´ (0,0) ƒë·∫øn (x,y)
    public int getSum(int x, int y) {
        x++; y++; // Chuy·ªÉn sang ch·ªâ s·ªë 1-based
        int sum = 0;

        for (int i = x; i > 0; i -= i & -i) {
            for (int j = y; j > 0; j -= j & -j) {
                sum += bit[i][j];
            }
        }

        return sum;
    }

    // Truy v·∫•n t·ªïng trong h√¨nh ch·ªØ nh·∫≠t [(x1,y1), (x2,y2)]
    public int getSumRange(int x1, int y1, int x2, int y2) {
        return getSum(x2, y2) - getSum(x2, y1 - 1) - getSum(x1 - 1, y2) + getSum(x1 - 1, y1 - 1);
    }
}
```

### So s√°nh Segment Tree v√† Fenwick Tree

| Ti√™u ch√≠             | Segment Tree              | Fenwick Tree          |
| -------------------- | ------------------------- | --------------------- |
| ƒê·ªô ph·ª©c t·∫°p truy v·∫•n | O(log n)                  | O(log n)              |
| ƒê·ªô ph·ª©c t·∫°p c·∫≠p nh·∫≠t | O(log n)                  | O(log n)              |
| Kh√¥ng gian b·ªô nh·ªõ    | O(n) (2n-1 n√∫t)           | O(n) (n n√∫t)          |
| Tri·ªÉn khai           | Ph·ª©c t·∫°p h∆°n              | ƒê∆°n gi·∫£n h∆°n          |
| H·ªó tr·ª£ truy v·∫•n      | Min, Max, Sum, GCD, ...   | Ch·ªß y·∫øu l√† Sum        |
| H·ªó tr·ª£ c·∫≠p nh·∫≠t ƒëo·∫°n | C√≥ (v·ªõi lazy propagation) | Kh√¥ng tr·ª±c ti·∫øp       |
| ·ª®ng d·ª•ng             | ƒêa d·∫°ng c√°c lo·∫°i truy v·∫•n | Truy v·∫•n t·ªïng ti·ªÅn t·ªë |

### ·ª®ng d·ª•ng c·ªßa Segment Tree v√† Fenwick Tree

1. **Truy v·∫•n t·ªïng ƒëo·∫°n (Range Sum Query)**: T√≠nh t·ªïng c·ªßa c√°c ph·∫ßn t·ª≠ trong m·ªôt ƒëo·∫°n.
2. **Truy v·∫•n gi√° tr·ªã nh·ªè nh·∫•t/l·ªõn nh·∫•t ƒëo·∫°n (Range Min/Max Query)**.
3. **Truy v·∫•n GCD/LCM ƒëo·∫°n**: T√¨m ∆∞·ªõc chung l·ªõn nh·∫•t ho·∫∑c b·ªôi chung nh·ªè nh·∫•t c·ªßa c√°c ph·∫ßn t·ª≠ trong ƒëo·∫°n.
4. **Truy v·∫•n ƒë·∫øm (Range Count Query)**: ƒê·∫øm s·ªë ph·∫ßn t·ª≠ th·ªèa m√£n m·ªôt ƒëi·ªÅu ki·ªán trong ƒëo·∫°n.
5. **C·∫•u tr√∫c d·ªØ li·ªáu trong c∆° s·ªü d·ªØ li·ªáu**: ƒê·ªÉ t·ªëi ∆∞u c√°c truy v·∫•n t·ªïng h·ª£p d·ªØ li·ªáu.
6. **C√°c b√†i to√°n h√¨nh h·ªçc t√≠nh to√°n**: Nh∆∞ ƒë·∫øm s·ªë ƒëi·ªÉm n·∫±m trong m·ªôt h√¨nh ch·ªØ nh·∫≠t.

### B√†i luy·ªán t·∫≠p

#### B√†i t·∫≠p 1: Truy v·∫•n t·ªïng ƒëo·∫°n v√† c·∫≠p nh·∫≠t ph·∫ßn t·ª≠

```java
public static void main(String[] args) {
    int[] arr = {1, 3, 5, 7, 9, 11};
    SegmentTree segTree = new SegmentTree(arr);

    // Truy v·∫•n t·ªïng ƒëo·∫°n [1, 3]
    System.out.println("T·ªïng ƒëo·∫°n [1, 3]: " + segTree.getSum(1, 3)); // K·∫øt qu·∫£: 15

    // C·∫≠p nh·∫≠t ph·∫ßn t·ª≠ arr[1] th√†nh 10
    segTree.update(1, 10);

    // Truy v·∫•n l·∫°i t·ªïng ƒëo·∫°n [1, 3]
    System.out.println("T·ªïng ƒëo·∫°n [1, 3] sau c·∫≠p nh·∫≠t: " + segTree.getSum(1, 3)); // K·∫øt qu·∫£: 22
}
```

#### B√†i t·∫≠p 2: Truy v·∫•n gi√° tr·ªã nh·ªè nh·∫•t ƒëo·∫°n

```java
// Segment Tree cho truy v·∫•n nh·ªè nh·∫•t
class MinSegmentTree {
    int[] tree;
    int n;

    public MinSegmentTree(int[] arr) {
        n = arr.length;
        int height = (int) Math.ceil(Math.log(n) / Math.log(2));
        int maxSize = 2 * (int) Math.pow(2, height) - 1;

        tree = new int[maxSize];
        buildSegmentTree(arr, 0, n - 1, 0);
    }

    private int buildSegmentTree(int[] arr, int start, int end, int index) {
        if (start == end) {
            tree[index] = arr[start];
            return tree[index];
        }

        int mid = start + (end - start) / 2;
        int leftMin = buildSegmentTree(arr, start, mid, 2 * index + 1);
        int rightMin = buildSegmentTree(arr, mid + 1, end, 2 * index + 2);

        tree[index] = Math.min(leftMin, rightMin);

        return tree[index];
    }

    public int getMin(int qStart, int qEnd) {
        if (qStart < 0 || qEnd >= n || qStart > qEnd)
            return Integer.MAX_VALUE;

        return getMinUtil(0, n - 1, qStart, qEnd, 0);
    }

    private int getMinUtil(int start, int end, int qStart, int qEnd, int index) {
        if (qStart <= start && qEnd >= end)
            return tree[index];

        if (end < qStart || start > qEnd)
            return Integer.MAX_VALUE;

        int mid = start + (end - start) / 2;

        int leftMin = getMinUtil(start, mid, qStart, qEnd, 2 * index + 1);
        int rightMin = getMinUtil(mid + 1, end, qStart, qEnd, 2 * index + 2);

        return Math.min(leftMin, rightMin);
    }
}

// S·ª≠ d·ª•ng:
int[] arr = {5, 2, 8, 1, 9, 3};
MinSegmentTree minTree = new MinSegmentTree(arr);
System.out.println("Gi√° tr·ªã nh·ªè nh·∫•t trong ƒëo·∫°n [1, 4]: " + minTree.getMin(1, 4)); // K·∫øt qu·∫£: 1
```

#### B√†i t·∫≠p 3: ƒê·∫øm s·ªë ph·∫ßn t·ª≠ l·ªõn h∆°n ho·∫∑c b·∫±ng k trong ƒëo·∫°n [l, r]

```java
// X√¢y d·ª±ng Segment Tree ƒë·∫∑c bi·ªát
class CountSegmentTree {
    class Node {
        int count; // S·ªë ph·∫ßn t·ª≠ trong ƒëo·∫°n
        int[] frequency; // T·∫ßn su·∫•t c·ªßa c√°c gi√° tr·ªã (gi·∫£ s·ª≠ gi√° tr·ªã t·ª´ 0-100)

        public Node() {
            count = 0;
            frequency = new int[101]; // Gi·∫£ s·ª≠ gi√° tr·ªã t·ª´ 0-100
        }
    }

    Node[] tree;
    int n;

    public CountSegmentTree(int[] arr) {
        n = arr.length;
        int height = (int) Math.ceil(Math.log(n) / Math.log(2));
        int maxSize = 2 * (int) Math.pow(2, height) - 1;

        tree = new Node[maxSize];
        for (int i = 0; i < maxSize; i++)
            tree[i] = new Node();

        buildSegmentTree(arr, 0, n - 1, 0);
    }

    private void buildSegmentTree(int[] arr, int start, int end, int index) {
        if (start == end) {
            tree[index].count = 1;
            tree[index].frequency[arr[start]]++;
            return;
        }

        int mid = start + (end - start) / 2;

        buildSegmentTree(arr, start, mid, 2 * index + 1);
        buildSegmentTree(arr, mid + 1, end, 2 * index + 2);

        tree[index].count = tree[2 * index + 1].count + tree[2 * index + 2].count;

        // C·ªông t·∫ßn su·∫•t t·ª´ c√°c n√∫t con
        for (int i = 0; i <= 100; i++) {
            tree[index].frequency[i] = tree[2 * index + 1].frequency[i] + tree[2 * index + 2].frequency[i];
        }
    }

    // ƒê·∫øm s·ªë ph·∫ßn t·ª≠ >= k trong ƒëo·∫°n [qStart, qEnd]
    public int countGreaterOrEqual(int qStart, int qEnd, int k) {
        if (qStart < 0 || qEnd >= n || qStart > qEnd)
            return 0;

        return countGreaterOrEqualUtil(0, n - 1, qStart, qEnd, k, 0);
    }

    private int countGreaterOrEqualUtil(int start, int end, int qStart, int qEnd, int k, int index) {
        if (qStart <= start && qEnd >= end) {
            int count = 0;
            for (int i = k; i <= 100; i++) {
                count += tree[index].frequency[i];
            }
            return count;
        }

        if (end < qStart || start > qEnd)
            return 0;

        int mid = start + (end - start) / 2;

        return countGreaterOrEqualUtil(start, mid, qStart, qEnd, k, 2 * index + 1) +
               countGreaterOrEqualUtil(mid + 1, end, qStart, qEnd, k, 2 * index + 2);
    }
}
```

## üßë‚Äçüíª B√†i t·∫≠p l·ªõn: X√¢y d·ª±ng h·ªá th·ªëng t√¨m ki·∫øm vƒÉn b·∫£n ƒë∆°n gi·∫£n

### M√¥ t·∫£ b√†i to√°n

X√¢y d·ª±ng m·ªôt h·ªá th·ªëng t√¨m ki·∫øm vƒÉn b·∫£n ƒë∆°n gi·∫£n c√≥ th·ªÉ:

1. L·∫≠p ch·ªâ m·ª•c cho m·ªôt t·∫≠p vƒÉn b·∫£n (indexing)
2. T√¨m ki·∫øm c√°c t√†i li·ªáu ch·ª©a t·ª´ kh√≥a (keyword search)
3. T√¨m ki·∫øm c√°c t√†i li·ªáu ch·ª©a nhi·ªÅu t·ª´ kh√≥a theo ƒë·ªô ph√π h·ª£p (ranking)
4. G·ª£i √Ω t·ª´ kh√≥a khi ng∆∞·ªùi d√πng nh·∫≠p (autocomplete)

### C√°c th√†nh ph·∫ßn c·∫ßn tri·ªÉn khai

1. **Document Manager**: Qu·∫£n l√Ω v√† l∆∞u tr·ªØ c√°c t√†i li·ªáu
2. **Tokenizer**: Ph√¢n t√°ch vƒÉn b·∫£n th√†nh c√°c t·ª´
3. **Inverted Index**: C·∫•u tr√∫c d·ªØ li·ªáu l∆∞u tr·ªØ √°nh x·∫° t·ª´ t·ª´ kh√≥a ƒë·∫øn c√°c t√†i li·ªáu
4. **Trie**: H·ªó tr·ª£ ch·ª©c nƒÉng g·ª£i √Ω t·ª´ kh√≥a
5. **Search Engine**: X·ª≠ l√Ω truy v·∫•n v√† x·∫øp h·∫°ng k·∫øt qu·∫£

### C√°c t√≠nh nƒÉng m·ªü r·ªông c√≥ th·ªÉ th√™m v√†o

1. **Stemming**: Chuy·ªÉn ƒë·ªïi c√°c t·ª´ v·ªÅ d·∫°ng g·ªëc (v√≠ d·ª•: "running" -> "run")
2. **Phrase Search**: T√¨m ki·∫øm c·ª•m t·ª´ ch√≠nh x√°c, kh√¥ng ch·ªâ l√† c√°c t·ª´ ri√™ng l·∫ª
3. **Boolean Search**: H·ªó tr·ª£ c√°c to√°n t·ª≠ logic nh∆∞ AND, OR, NOT
4. **Fuzzy Search**: T√¨m ki·∫øm c√°c t·ª´ g·∫ßn gi·ªëng v·ªõi t·ª´ kh√≥a
5. **Highlighting**: ƒê√°nh d·∫•u c√°c t·ª´ kh√≥a trong k·∫øt qu·∫£ t√¨m ki·∫øm
6. **Pagination**: Ph√¢n trang k·∫øt qu·∫£ t√¨m ki·∫øm
7. **Filtering**: L·ªçc k·∫øt qu·∫£ theo c√°c ti√™u ch√≠ kh√°c nhau
